/**
 * 非战斗金币技能实现
 * Non-Battle Gold Skills
 *
 * 包含所有非战斗阶段使用的金币技能
 * - 这些技能主要在非战斗阶段使用
 * - 包含城市管理、资源操作、状态控制等效果
 */

import { useGameStore } from '../../stores/gameStore'
import { checkAndDeductGold } from '../../constants/skillCosts'
import { addSkillUsageLog, addSkillEffectLog } from '../game/logUtils'

export function useNonBattleSkills() {
  const gameStore = useGameStore()

  /**
   * 转账给他人
   */
  function executeTransferGold(caster, target, amount) {
    if (!amount || amount <= 0) {
      return { success: false, message: '转账金额无效' }
    }

    if (caster.gold < amount) {
      return { success: false, message: '金币不足' }
    }

    if (target.gold + amount > 24) {
      return { success: false, message: '对方金币已达上限24' }
    }

    caster.gold -= amount
    target.gold += amount

    // 双日志
    addSkillUsageLog(
      gameStore,
      caster.name,
      '转账给他人',
      `转账${amount}金币给${target.name}`,
      `你转账${amount}金币给${target.name}`
    )

    return {
      success: true,
      message: `成功转账${amount}金币`
    }
  }

  /**
   * 无知无畏 - 血量最低城市攻击中心
   */
  function executeWuZhiWuWei(caster, target) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('无知无畏', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '无知无畏')) {
      // 双日志：被阻挡
      addSkillUsageLog(
        gameStore,
        caster.name,
        '无知无畏',
        `无知无畏被${target.name}的坚不可摧护盾阻挡`,
        `你使用了无知无畏，但被${target.name}的坚不可摧护盾阻挡`
      )
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    const aliveCities = caster.cities.filter(c => c.isAlive !== false && (c.currentHp || c.hp) > 0)
    if (aliveCities.length === 0) {
      return { success: false, message: '没有可用城市' }
    }

    // 找到血量最低的城市
    const lowestHpCity = aliveCities.reduce((min, city) =>
      (city.currentHp || city.hp) < (min.currentHp || min.hp) ? city : min
    )

    const cityIdx = caster.cities.indexOf(lowestHpCity)
    const attackerHp = lowestHpCity.currentHp || lowestHpCity.hp

    // 判断攻击者是否为中心城市
    const isCenterAttack = (cityIdx === (caster.centerIndex || 0))

    // 计算伤害：如果是中心城市攻击，伤害×2
    let damage = attackerHp
    if (isCenterAttack) {
      damage *= 2
    }

    // 伤害上限：非中心攻击者7500，中心攻击者15000
    const dmgCap = isCenterAttack ? 15000 : 7500
    damage = Math.min(damage, dmgCap)

    // 自毁城市
    lowestHpCity.isAlive = false
    lowestHpCity.currentHp = 0

    // 添加到deadCities列表
    if (!gameStore.deadCities[caster.name]) {
      gameStore.deadCities[caster.name] = []
    }
    if (cityIdx !== -1 && !gameStore.deadCities[caster.name].includes(cityIdx)) {
      gameStore.deadCities[caster.name].push(cityIdx)
    }

    // 对目标中心造成伤害（需要处理屏障）
    let actualDamage = damage

    // 检查目标是否有屏障
    if (gameStore.barrier[target.name] && gameStore.barrier[target.name].hp > 0) {
      const barrier = gameStore.barrier[target.name]
      const barrierDamage = Math.min(actualDamage, barrier.hp)
      barrier.hp -= barrierDamage
      actualDamage -= barrierDamage

      addSkillEffectLog(gameStore, `${target.name}的屏障吸收了${barrierDamage}点伤害，剩余${barrier.hp}HP`)

      if (barrier.hp <= 0) {
        delete gameStore.barrier[target.name]
        addSkillEffectLog(gameStore, `${target.name}的屏障被摧毁`)
      }
    }

    // 如果还有剩余伤害，对中心城市造成伤害
    if (actualDamage > 0) {
      // 找到中心城市
      const centerCity = target.cities.find(c => c.isCenter)
      if (centerCity) {
        const currentHp = centerCity.currentHp || centerCity.hp
        centerCity.currentHp = Math.max(0, currentHp - actualDamage)

        if (centerCity.currentHp <= 0) {
          centerCity.isAlive = false
          addSkillEffectLog(gameStore, `${target.name}的中心城市${centerCity.name}被摧毁`)
        } else {
          addSkillEffectLog(gameStore, `${target.name}的中心城市受到${actualDamage}点伤害`)
        }
      }
    }

    // 双日志
    addSkillUsageLog(
      gameStore,
      caster.name,
      '无知无畏',
      `用${lowestHpCity.name}${isCenterAttack ? '（中心城市，伤害×2）' : ''}使用无知无畏，对${target.name}造成${damage}伤害后自毁`,
      `你用${lowestHpCity.name}使用了无知无畏`
    )

    return {
      success: true,
      message: `${lowestHpCity.name}攻击中心后自毁，造成${damage}伤害${isCenterAttack ? '（中心×2）' : ''}`
    }
  }

  /**
   * 快速治疗 - 恢复至满血
   */
  function executeKuaiSuZhiLiao(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    if (!selfCity.isAlive) {
      return { success: false, message: '城市已阵亡' }
    }

    // 检查是否已满血
    const currentHp = selfCity.currentHp || selfCity.hp
    if (currentHp >= selfCity.hp) {
      return { success: false, message: '城市已满血' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('快速治疗', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const healed = selfCity.hp - currentHp
    selfCity.currentHp = selfCity.hp

    gameStore.addLog(`${caster.name} 对${selfCity.name}使用快速治疗，恢复${healed}HP`)

    return {
      success: true,
      message: `${selfCity.name}恢复至满血`
    }
  }

  /**
   * 城市保护 - 添加保护罩
   */
  function executeCityProtection(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // 获取城市索引
    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 检查是否已有保护
    if (gameStore.protections[caster.name]?.[cityIdx]) {
      return { success: false, message: '该城市已有保护' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('城市保护', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 在gameStore中设置保护罩
    if (!gameStore.protections[caster.name]) {
      gameStore.protections[caster.name] = {}
    }
    gameStore.protections[caster.name][cityIdx] = 10

    gameStore.addLog(`${caster.name} 对${selfCity.name}使用城市保护，10回合内免疫1次技能`)

    return {
      success: true,
      message: `${selfCity.name}获得保护罩，10回合内免疫1次技能`
    }
  }

  /**
   * 钢铁城市 - 添加钢铁护盾
   */
  function executeGangTieChengShi(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // 获取城市索引
    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 检查是否已经是钢铁城市
    if (gameStore.ironCities[caster.name] && gameStore.ironCities[caster.name][cityIdx]) {
      return {
        success: false,
        message: '该城市已经是钢铁城市'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('钢铁城市', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 在gameStore中设置钢铁护盾（2层免疫）
    if (!gameStore.ironCities[caster.name]) {
      gameStore.ironCities[caster.name] = {}
    }
    gameStore.ironCities[caster.name][cityIdx] = 2  // ✅ 修复：设置为2层，而非true

    gameStore.addLog(`${caster.name} 对${selfCity.name}使用钢铁城市，免疫2次技能侵害`)

    return {
      success: true,
      message: `${selfCity.name}成为钢铁城市，免疫2次技能侵害（第一次后变普通护盾）`
    }
  }

  /**
   * 实力增强 - HP翻倍
   */
  function executeShiLiZengQiang(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // ✅ PDF明确说明："对中心无效"
    const cityIdx = caster.cities.indexOf(selfCity)
    const mode = gameStore.gameMode || '2P'

    if ((mode === '2P' || mode === '2v2') && cityIdx === caster.centerIndex) {
      return {
        success: false,
        message: '实力增强对中心城市无效'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('实力增强', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const currentHp = selfCity.currentHp || selfCity.hp
    selfCity.currentHp = Math.min(currentHp * 2, 50000)

    gameStore.addLog(`${caster.name} 对${selfCity.name}使用实力增强，HP翻倍`)

    return {
      success: true,
      message: `${selfCity.name}HP翻倍（上限50000）`
    }
  }

  /**
   * 借尸还魂 - 复活城市
   */
  function executeJieShiHuanHun(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    if (selfCity.isAlive !== false) {
      return { success: false, message: '城市未阵亡，无需复活' }
    }

    // 检查是否有待处理的先声夺人请求（避免冲突）
    if (gameStore.pendingPreemptiveStrike) {
      return {
        success: false,
        message: '当前有待处理的先声夺人请求，请先完成'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('借尸还魂', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 从ALL_CITIES或baseHp获取原始HP
    const originalCity = gameStore.getCityByName(selfCity.name)
    const baseHp = selfCity.baseHp || originalCity?.hp || selfCity.hp

    // 复活到50%HP，上限5000
    const reviveHp = Math.min(Math.floor(baseHp * 0.5), 5000)

    // 复活城市
    selfCity.isAlive = true
    selfCity.currentHp = reviveHp

    // 清除疲劳指数
    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx !== -1) {
      if (!gameStore.fatigueStreaks[caster.name]) {
        gameStore.fatigueStreaks[caster.name] = {}
      }
      gameStore.fatigueStreaks[caster.name][cityIdx] = 0
    }

    // 从deadCities列表移除
    if (gameStore.deadCities[caster.name]) {
      const deadIdx = gameStore.deadCities[caster.name].indexOf(cityIdx)
      if (deadIdx > -1) {
        gameStore.deadCities[caster.name].splice(deadIdx, 1)
      }
    }

    // 如果总城市数≤5，自动加入roster
    if (caster.cities.length <= 5 && cityIdx !== -1) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      if (!gameStore.roster[caster.name].includes(cityIdx)) {
        gameStore.roster[caster.name].push(cityIdx)
      }
    }

    gameStore.addLog(`${caster.name} 对${selfCity.name}使用借尸还魂，复活并恢复${reviveHp}HP（疲劳已清除）`)

    return {
      success: true,
      message: `${selfCity.name}复活，恢复${reviveHp}HP`
    }
  }

  /**
   * 士气大振 - 所有城市满血
   */
  function executeShiQiDaZhen(caster) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('士气大振', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // ✅ PDF明确说明："立即恢复所有预备城市至满血"，而非所有城市
    const rosterIndices = gameStore.roster[caster.name] || []
    if (rosterIndices.length === 0) {
      return {
        success: false,
        message: '没有预备城市可恢复'
      }
    }

    let count = 0
    rosterIndices.forEach(idx => {
      const city = caster.cities[idx]
      if (city && city.isAlive !== false) {
        city.currentHp = city.hp
        count++
      }
    })

    gameStore.addLog(`${caster.name} 使用士气大振，${count}个预备城市恢复至满血`)

    return {
      success: true,
      message: `所有预备城市恢复至满血`
    }
  }

  /**
   * 清除加成 - 移除所有增益
   */
  function executeQingChuJiaCheng(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '清除加成')) {
      gameStore.addLog(`${caster.name}使用清除加成，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('清除加成', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取城市索引
    const cityIdx = target.cities.indexOf(targetCity)

    // 消耗一层保护罩/钢铁护盾（如果有）
    const consumed = gameStore.consumeProtection(target.name, cityIdx)

    if (consumed) {
      gameStore.addLog(`清除加成效果被${target.name}的${targetCity.name}护盾抵消`)
      return {
        success: true,
        message: `效果被护盾抵消`
      }
    }

    // 清除所有modifier
    targetCity.modifiers = []

    // 清除HP超过上限的部分
    const currentHp = targetCity.currentHp || targetCity.hp
    if (currentHp > targetCity.hp) {
      targetCity.currentHp = targetCity.hp
    }

    gameStore.addLog(`清除了${target.name}的${targetCity.name}的所有加成`)

    return {
      success: true,
      message: `清除了${targetCity.name}的所有加成效果`
    }
  }

  /**
   * 时来运转 - 随机交换3张卡牌
   */
  function executeShiLaiYunZhuan(caster, target) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('时来运转', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 前置检查1：检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '时来运转')) {
      gameStore.addLog(`${caster.name}使用时来运转，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 前置检查2：构建可交换城市池（排除：谨慎交换集合、保护、定海神针、阵亡、中心城市、钢铁城市）
    function getEligibleCities(player) {
      const eligible = []
      player.cities.forEach((city, idx) => {
        // 已阵亡不参与
        if (city.isAlive === false) return

        // 谨慎交换集合不参与
        if (gameStore.isInCautiousSet(player.name, idx)) return

        // 被保护不参与
        if (gameStore.hasProtection(player.name, idx)) return

        // 定海神针不参与
        if (gameStore.anchored[player.name] && gameStore.anchored[player.name][idx]) return

        // 中心城市不参与
        if (city.isCenter) return

        // 钢铁城市不参与
        if (gameStore.hasIronShield(player.name, idx)) return

        eligible.push(idx)
      })
      return eligible
    }

    const eligibleCaster = getEligibleCities(caster)
    const eligibleTarget = getEligibleCities(target)

    // 前置检查3：可交换城市数量检查
    if (eligibleCaster.length < 3 || eligibleTarget.length < 3) {
      return {
        success: false,
        message: `可交换城市不足：${caster.name}可选${eligibleCaster.length}张、${target.name}可选${eligibleTarget.length}张（需各≥3）`
      }
    }

    // 随机选择3个城市（简化版不实现李代桃僵手动选择）
    function pick3Random(arr) {
      const shuffled = [...arr]
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        ;[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]
      }
      return shuffled.slice(0, 3)
    }

    const casterPicks = pick3Random(eligibleCaster)
    const targetPicks = pick3Random(eligibleTarget)

    // 处理狐假虎威伪装城市（被交换时自毁并识破）
    const exposedCaster = []
    const exposedTarget = []
    const normalCaster = []
    const normalTarget = []

    casterPicks.forEach(idx => {
      const disguise = gameStore.disguisedCities[caster.name]?.[idx]
      if (disguise && disguise.roundsLeft > 0) {
        // 伪装城市被识破，自毁
        const city = caster.cities[idx]
        city.isAlive = false
        city.currentHp = 0

        // 如果未付费，扣9金币
        if (!disguise.paid) {
          caster.gold = Math.max(0, caster.gold - 9)
          disguise.paid = true
        }

        // 清除伪装
        disguise.roundsLeft = 0
        exposedCaster.push({ fake: disguise.fakeName, real: city.name })
      } else {
        normalCaster.push({ idx, name: caster.cities[idx].name })
      }
    })

    targetPicks.forEach(idx => {
      const disguise = gameStore.disguisedCities[target.name]?.[idx]
      if (disguise && disguise.roundsLeft > 0) {
        // 伪装城市被识破，自毁
        const city = target.cities[idx]
        city.isAlive = false
        city.currentHp = 0

        // 如果未付费，扣9金币
        if (!disguise.paid) {
          target.gold = Math.max(0, target.gold - 9)
          disguise.paid = true
        }

        // 清除伪装
        disguise.roundsLeft = 0
        exposedTarget.push({ fake: disguise.fakeName, real: city.name })
      } else {
        normalTarget.push({ idx, name: target.cities[idx].name })
      }
    })

    // 实际交换普通城市（伪装城市已自毁，不参与交换）
    const minLen = Math.min(normalCaster.length, normalTarget.length)
    const swappedPairs = []

    for (let k = 0; k < minLen; k++) {
      const casterIdx = normalCaster[k].idx
      const targetIdx = normalTarget[k].idx

      // 交换城市对象
      const temp = caster.cities[casterIdx]
      caster.cities[casterIdx] = target.cities[targetIdx]
      target.cities[targetIdx] = temp

      // 同步交换initialCities
      if (gameStore.initialCities[caster.name] && gameStore.initialCities[target.name]) {
        const tempInitial = gameStore.initialCities[caster.name][casterIdx]
        gameStore.initialCities[caster.name][casterIdx] = gameStore.initialCities[target.name][targetIdx]
        gameStore.initialCities[target.name][targetIdx] = tempInitial
      }

      // 标记城市为已知
      gameStore.setCityKnown(caster.name, casterIdx, target.name)
      gameStore.setCityKnown(target.name, targetIdx, caster.name)

      swappedPairs.push({
        casterCity: target.cities[targetIdx].name,  // 交换后的城市
        targetCity: caster.cities[casterIdx].name
      })
    }

    // 重置双方出战状态和疲劳计数器
    if (gameStore.fatigueStreaks[caster.name]) {
      Object.keys(gameStore.fatigueStreaks[caster.name]).forEach(idx => {
        gameStore.fatigueStreaks[caster.name][idx] = 0
      })
    }
    if (gameStore.fatigueStreaks[target.name]) {
      Object.keys(gameStore.fatigueStreaks[target.name]).forEach(idx => {
        gameStore.fatigueStreaks[target.name][idx] = 0
      })
    }

    // 日志记录
    gameStore.addLog(`>>> ${caster.name}对${target.name}使用时来运转`)

    if (swappedPairs.length > 0) {
      const swapText = swappedPairs.map((pair, i) =>
        `第${i+1}对：${caster.name}的${pair.casterCity} ⇄ ${target.name}的${pair.targetCity}`
      ).join('，')
      gameStore.addLog(swapText)
    }

    if (exposedCaster.length > 0) {
      const details = exposedCaster.map(x => `${x.fake}（实为${x.real}，狐假虎威被识破并自毁）`).join('、')
      gameStore.addLog(`${caster.name}的${details}`)
    }

    if (exposedTarget.length > 0) {
      const details = exposedTarget.map(x => `${x.fake}（实为${x.real}，狐假虎威被识破并自毁）`).join('、')
      gameStore.addLog(`${target.name}的${details}`)
    }

    return {
      success: true,
      message: `交换了${swappedPairs.length}对城市${exposedCaster.length + exposedTarget.length > 0 ? '，部分伪装城市被识破' : ''}`
    }
  }

  /**
   * 先声夺人 - 交换1张卡牌（冷却3回合，每局限2次）
   */
  function executeXianShengDuoRen(caster, target, params = {}) {
    const { casterCityIdx, targetCityIdx } = params

    // 前置检查0：检查使用次数（每局限2次）
    if (!gameStore.xianshengduorenUsageCount) {
      gameStore.xianshengduorenUsageCount = {}
    }
    if (!gameStore.xianshengduorenUsageCount[caster.name]) {
      gameStore.xianshengduorenUsageCount[caster.name] = 0
    }
    if (gameStore.xianshengduorenUsageCount[caster.name] >= 2) {
      return {
        success: false,
        message: '先声夺人每局最多使用2次'
      }
    }

    // 前置检查0.5：检查冷却时间（3回合）
    if (gameStore.cooldowns && gameStore.cooldowns[caster.name] &&
        gameStore.cooldowns[caster.name]['先声夺人'] > 0) {
      const remainingCooldown = gameStore.cooldowns[caster.name]['先声夺人']
      return {
        success: false,
        message: `先声夺人冷却中，剩余${remainingCooldown}回合`
      }
    }

    // 前置检查1：检查是否有待处理的先声夺人请求（避免冲突）
    if (gameStore.pendingPreemptiveStrike) {
      return {
        success: false,
        message: '当前有待处理的先声夺人请求，请先完成'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('先声夺人', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 增加使用次数
    gameStore.xianshengduorenUsageCount[caster.name]++

    // 设置冷却时间（3回合）
    if (!gameStore.cooldowns) {
      gameStore.cooldowns = {}
    }
    if (!gameStore.cooldowns[caster.name]) {
      gameStore.cooldowns[caster.name] = {}
    }
    gameStore.cooldowns[caster.name]['先声夺人'] = 3

    // 前置检查2：构建可交换城市池（排除：谨慎交换集合、阵亡、中心城市、定海神针、钢铁城市、保护）
    function getEligibleCities(player) {
      const eligible = []
      player.cities.forEach((city, idx) => {
        // 已阵亡不参与
        if (city.isAlive === false) return

        // 谨慎交换集合不参与
        if (gameStore.isInCautiousSet(player.name, idx)) return

        // 中心城市不参与
        if (city.isCenter) return

        // 定海神针不参与
        if (gameStore.anchored[player.name] && gameStore.anchored[player.name][idx]) return

        // 钢铁城市不参与
        if (gameStore.hasIronShield(player.name, idx)) return

        // 被保护不参与
        if (gameStore.hasProtection(player.name, idx)) return

        eligible.push(idx)
      })
      return eligible
    }

    const eligibleCaster = getEligibleCities(caster)
    const eligibleTarget = getEligibleCities(target)

    // 前置检查3：可交换城市数量检查
    if (eligibleCaster.length === 0 || eligibleTarget.length === 0) {
      return {
        success: false,
        message: '双方至少有一方没有可交换的城市（排除谨慎交换集合）'
      }
    }

    // 确定要交换的城市索引
    let selectedCasterIdx, selectedTargetIdx

    if (casterCityIdx !== undefined && targetCityIdx !== undefined) {
      // 使用指定的城市索引
      selectedCasterIdx = casterCityIdx
      selectedTargetIdx = targetCityIdx

      // 验证城市索引有效性
      if (!eligibleCaster.includes(selectedCasterIdx)) {
        return {
          success: false,
          message: '发起者选择的城市不可交换'
        }
      }
      if (!eligibleTarget.includes(selectedTargetIdx)) {
        return {
          success: false,
          message: '目标玩家选择的城市不可交换'
        }
      }
    } else {
      // 随机选择城市（简化版）
      selectedCasterIdx = eligibleCaster[Math.floor(Math.random() * eligibleCaster.length)]
      selectedTargetIdx = eligibleTarget[Math.floor(Math.random() * eligibleTarget.length)]
    }

    const casterCity = caster.cities[selectedCasterIdx]
    const targetCity = target.cities[selectedTargetIdx]

    // 执行城市交换
    const temp = caster.cities[selectedCasterIdx]
    caster.cities[selectedCasterIdx] = target.cities[selectedTargetIdx]
    target.cities[selectedTargetIdx] = temp

    // 同步交换initialCities中的数据（保持原始HP跟随城市移动）
    if (gameStore.initialCities[caster.name] && gameStore.initialCities[target.name]) {
      const tempInitial = gameStore.initialCities[caster.name][selectedCasterIdx]
      gameStore.initialCities[caster.name][selectedCasterIdx] =
        gameStore.initialCities[target.name][selectedTargetIdx]
      gameStore.initialCities[target.name][selectedTargetIdx] = tempInitial
    }

    // 清除被交换城市的狐假虎威伪装状态
    if (gameStore.disguisedCities[caster.name]) {
      delete gameStore.disguisedCities[caster.name][selectedCasterIdx]
    }
    if (gameStore.disguisedCities[target.name]) {
      delete gameStore.disguisedCities[target.name][selectedTargetIdx]
    }

    // 标记城市为已知
    gameStore.setCityKnown(caster.name, selectedCasterIdx, target.name)
    gameStore.setCityKnown(target.name, selectedTargetIdx, caster.name)

    gameStore.addLog(
      `${caster.name}对${target.name}使用先声夺人，交换了${casterCity.name}和${targetCity.name}（冷却3回合，剩余${2 - gameStore.xianshengduorenUsageCount[caster.name]}次）`
    )

    return {
      success: true,
      message: `交换了${casterCity.name}和${targetCity.name}（剩余${2 - gameStore.xianshengduorenUsageCount[caster.name]}次）`
    }
  }

  /**
   * 金币贷款 - 获得5金币，但2回合无法获得金币（每局限1次）
   */
  function executeJinBiDaiKuan(caster) {
    // 检查使用次数（每局限1次）
    if (!gameStore.jinbidaikuanUsageCount) {
      gameStore.jinbidaikuanUsageCount = {}
    }
    if (gameStore.jinbidaikuanUsageCount[caster.name] >= 1) {
      return {
        success: false,
        message: '金币贷款每局只能使用1次'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('金币贷款', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 增加使用次数
    if (!gameStore.jinbidaikuanUsageCount[caster.name]) {
      gameStore.jinbidaikuanUsageCount[caster.name] = 0
    }
    gameStore.jinbidaikuanUsageCount[caster.name]++

    // 立即获得5金币（原版逻辑）
    caster.gold = Math.min(caster.gold + 5, 24)

    // 设置2回合冷却期（接下来2回合无法获得自动金币）
    caster.loanCooldown = 2

    gameStore.addLog(`${caster.name}使用金币贷款，获得5金币但接下来2回合无法获得自动金币（每局限1次）`)

    return {
      success: true,
      message: '获得5金币，但接下来2回合无法获得自动金币'
    }
  }

  /**
   * 定海神针 - 城市10回合不会被交换（冷却1回合，每局限3次）
   */
  function executeDingHaiShenZhen(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // 检查使用次数（每局限3次）
    if (!gameStore.dinghaishenzhenUsageCount) {
      gameStore.dinghaishenzhenUsageCount = {}
    }
    if (!gameStore.dinghaishenzhenUsageCount[caster.name]) {
      gameStore.dinghaishenzhenUsageCount[caster.name] = 0
    }
    if (gameStore.dinghaishenzhenUsageCount[caster.name] >= 3) {
      return {
        success: false,
        message: '定海神针每局最多使用3次'
      }
    }

    // 检查冷却时间（1回合）
    if (gameStore.cooldowns && gameStore.cooldowns[caster.name] &&
        gameStore.cooldowns[caster.name]['定海神针'] > 0) {
      const remainingCooldown = gameStore.cooldowns[caster.name]['定海神针']
      return {
        success: false,
        message: `定海神针冷却中，剩余${remainingCooldown}回合`
      }
    }

    // 获取城市索引
    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('定海神针', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 增加使用次数
    gameStore.dinghaishenzhenUsageCount[caster.name]++

    // 设置冷却时间（1回合）
    if (!gameStore.cooldowns) {
      gameStore.cooldowns = {}
    }
    if (!gameStore.cooldowns[caster.name]) {
      gameStore.cooldowns[caster.name] = {}
    }
    gameStore.cooldowns[caster.name]['定海神针'] = 1

    // 在gameStore中设置定海神针
    if (!gameStore.anchored[caster.name]) {
      gameStore.anchored[caster.name] = {}
    }
    gameStore.anchored[caster.name][cityIdx] = 10

    gameStore.addLog(`${caster.name}对${selfCity.name}使用定海神针，10回合内不会被交换（冷却1回合，剩余${3 - gameStore.dinghaishenzhenUsageCount[caster.name]}次）`)

    return {
      success: true,
      message: `${selfCity.name}已固定位置，10回合内不会被交换（剩余${3 - gameStore.dinghaishenzhenUsageCount[caster.name]}次）`
    }
  }

  /**
   * 焕然一新 - 恢复城市技能到初始状态（每局限2次）
   */
  function executeHuanRanYiXin(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('焕然一新', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 恢复到初始技能等级（假设存储在baseSkills中）
    selfCity.red = selfCity.baseSkills?.red || 0
    selfCity.green = selfCity.baseSkills?.green || 0
    selfCity.blue = selfCity.baseSkills?.blue || 0
    selfCity.yellow = selfCity.baseSkills?.yellow || 0

    gameStore.addLog(`${caster.name}对${selfCity.name}使用焕然一新，技能等级已恢复`)

    return {
      success: true,
      message: `${selfCity.name}技能等级已恢复到初始状态`
    }
  }

  /**
   * 苟延残喘 - 获得2个HP<1000的城市
   */
  function executeGouYanCanChuan(caster) {
    // 从未使用城市池中筛选HP<1000的城市
    const unusedCities = gameStore.getUnusedCities()
    const lowHpCities = unusedCities.filter(city => city.hp < 1000)

    if (lowHpCities.length < 2) {
      return {
        success: false,
        message: `城市池中HP<1000的城市不足（仅剩${lowHpCities.length}个）`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('苟延残喘', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 随机抽取2个
    const shuffled = lowHpCities.sort(() => Math.random() - 0.5)
    const selectedCities = shuffled.slice(0, 2)

    const addedCities = []

    for (const cityData of selectedCities) {
      // 创建城市副本
      const newCity = {
        name: cityData.name,
        hp: cityData.hp,
        currentHp: cityData.hp,
        baseHp: cityData.hp,
        isAlive: true,
        red: cityData.red || 0,
        green: cityData.green || 0,
        blue: cityData.blue || 0,
        yellow: cityData.yellow || 0,
        modifiers: []
      }

      // 添加到玩家城市列表
      caster.cities.push(newCity)
      addedCities.push(newCity)

      // 标记为已使用
      gameStore.markCityAsUsed(cityData.name)

      // 记录到initialCities
      if (!gameStore.initialCities[caster.name]) {
        gameStore.initialCities[caster.name] = []
      }
      gameStore.initialCities[caster.name].push(newCity)
    }

    // 如果总城市数≤5，自动加入roster
    if (caster.cities.length <= 5) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      // 加入最后两个城市的索引
      const idx1 = caster.cities.length - 2
      const idx2 = caster.cities.length - 1
      if (!gameStore.roster[caster.name].includes(idx1)) {
        gameStore.roster[caster.name].push(idx1)
      }
      if (!gameStore.roster[caster.name].includes(idx2)) {
        gameStore.roster[caster.name].push(idx2)
      }
    }

    gameStore.addLog(
      `${caster.name}使用苟延残喘，获得了${addedCities.map(c => `${c.name}(${c.hp})`).join('、')}`
    )

    return {
      success: true,
      message: `获得了2个小血量城市：${addedCities.map(c => c.name).join('、')}`
    }
  }

  /**
   * 高级治疗 - 2个城市撤下，2回合后满血返回
   */
  function executeGaoJiZhiLiao(caster, cityIndices) {
    if (!cityIndices || cityIndices.length !== 2) {
      return { success: false, message: '需要选择2个城市' }
    }

    // 筛选战斗预备且非满血的城市
    const cities = cityIndices.map(idx => {
      const city = caster.cities[idx]
      if (!city) return null

      // 检查是否在roster中
      const inRoster = gameStore.roster[caster.name] &&
                       gameStore.roster[caster.name].includes(idx)

      if (!inRoster) return null
      if (city.isAlive === false) return null

      // 检查是否非满血
      const currentHp = city.currentHp || city.hp
      if (currentHp >= city.hp) return null

      return { city, idx }
    }).filter(item => item !== null)

    if (cities.length !== 2) {
      return {
        success: false,
        message: '需要选择2个战斗预备且受伤的城市'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('高级治疗', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 从roster中移除这两个城市
    cities.forEach(({ idx }) => {
      const rosterIdx = gameStore.roster[caster.name].indexOf(idx)
      if (rosterIdx > -1) {
        gameStore.roster[caster.name].splice(rosterIdx, 1)
      }
    })

    // 设置healing状态（2回合后返回）
    cities.forEach(({ city, idx }) => {
      city.modifiers = city.modifiers || []
      city.modifiers.push({
        type: 'healing',
        roundsLeft: 2,
        returnHp: city.hp,  // 返回时恢复到满血
        originalIdx: idx
      })

      // 标记该城市正在治疗中（可用于UI显示）
      city.isInHealing = true
    })

    // 设置bannedCities禁用记录（2回合无法出战）
    if (!gameStore.bannedCities[caster.name]) {
      gameStore.bannedCities[caster.name] = {}
    }
    cities.forEach(({ idx }) => {
      gameStore.bannedCities[caster.name][idx] = 2
    })

    const cityNames = cities.map(({ city }) => city.name).join('、')
    gameStore.addLog(`${caster.name}对${cityNames}使用高级治疗，2回合后满血返回`)

    return {
      success: true,
      message: `${cityNames}撤下治疗，2回合后满血返回`
    }
  }

  /**
   * 众志成城 - 平均分配3-5个城市的HP
   */
  function executeZhongZhiChengCheng(caster, cityIndices) {
    // 检查己方存活城市数是否≥3
    const aliveCities = caster.cities.filter(c => c.isAlive !== false)
    if (aliveCities.length < 3) {
      return {
        success: false,
        message: '己方城市数需要≥3才能使用众志成城'
      }
    }

    if (!cityIndices || cityIndices.length < 3 || cityIndices.length > 5) {
      return { success: false, message: '需要选择3-5个城市' }
    }

    const cities = cityIndices.map(idx => caster.cities[idx]).filter(c => c && c.isAlive !== false)

    if (cities.length < 3) {
      return { success: false, message: '选择的存活城市数量不足3个' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('众志成城', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 计算总HP并平均分配
    const totalHp = cities.reduce((sum, c) => sum + (c.currentHp || c.hp), 0)
    const avgHp = Math.floor(totalHp / cities.length)

    cities.forEach(city => {
      city.currentHp = avgHp
    })

    gameStore.addLog(`${caster.name}使用众志成城，${cities.length}个城市HP平均为${avgHp}`)

    return {
      success: true,
      message: `${cities.length}个城市HP已平均分配为${avgHp}`
    }
  }

  /**
   * 无中生有 - 从城市池随机获得1座城市
   */
  function executeWuZhongShengYou(caster) {
    // 从未使用的城市池中抽取
    const unusedCities = gameStore.getUnusedCities()

    if (unusedCities.length === 0) {
      return {
        success: false,
        message: '城市池已空，无法抽取'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('无中生有', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 随机选择一个未使用的城市
    const randomCity = unusedCities[Math.floor(Math.random() * unusedCities.length)]

    // 创建城市副本（避免引用问题）
    const newCity = {
      name: randomCity.name,
      hp: randomCity.hp,
      currentHp: randomCity.hp,
      baseHp: randomCity.hp,
      isAlive: true,
      red: randomCity.red || 0,
      green: randomCity.green || 0,
      blue: randomCity.blue || 0,
      yellow: randomCity.yellow || 0,
      modifiers: []
    }

    // 添加到玩家城市列表
    caster.cities.push(newCity)

    // 标记为已使用
    gameStore.markCityAsUsed(randomCity.name)

    // 记录到initialCities（如果有该系统）
    if (!gameStore.initialCities[caster.name]) {
      gameStore.initialCities[caster.name] = []
    }
    gameStore.initialCities[caster.name].push(newCity)

    // 如果总城市数≤5，自动加入roster
    if (caster.cities.length <= 5) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      const newIdx = caster.cities.length - 1
      if (!gameStore.roster[caster.name].includes(newIdx)) {
        gameStore.roster[caster.name].push(newIdx)
      }
    }

    gameStore.addLog(`${caster.name}使用无中生有，获得了${newCity.name}(HP: ${newCity.hp})`)

    return {
      success: true,
      message: `获得了${newCity.name}(HP: ${newCity.hp})`
    }
  }

  /**
   * 好高骛远 - 用血量更高的城市替换
   */
  function executeHaoGaoWuYuan(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const currentHp = selfCity.currentHp || selfCity.hp

    // 从未使用城市池中筛选HP更高的城市
    const unusedCities = gameStore.getUnusedCities()
    const higherHpCities = unusedCities.filter(city => city.hp > currentHp)

    if (higherHpCities.length === 0) {
      return {
        success: false,
        message: '城市池中没有HP更高的城市'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('好高骛远', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 随机选择一个HP更高的城市
    const randomCity = higherHpCities[Math.floor(Math.random() * higherHpCities.length)]

    // 创建新城市（保留原城市的技能等级）
    const newCity = {
      name: randomCity.name,
      hp: randomCity.hp,
      currentHp: randomCity.hp,
      baseHp: randomCity.hp,
      isAlive: true,
      red: selfCity.red || 0,     // 保留原技能等级
      green: selfCity.green || 0,
      blue: selfCity.blue || 0,
      yellow: selfCity.yellow || 0,
      modifiers: selfCity.modifiers || []
    }

    // 找到原城市在数组中的索引
    const idx = caster.cities.indexOf(selfCity)
    if (idx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 替换城市
    caster.cities[idx] = newCity

    // 标记新城市为已使用
    gameStore.markCityAsUsed(randomCity.name)

    // 更新initialCities（为新城市创建正确的初始记录）
    if (gameStore.initialCities[caster.name]) {
      gameStore.initialCities[caster.name][idx] = {
        name: newCity.name,
        hp: newCity.hp,
        currentHp: newCity.hp,
        baseHp: newCity.hp,
        isAlive: true,
        red: newCity.red,
        green: newCity.green,
        blue: newCity.blue,
        yellow: newCity.yellow
      }
    }

    gameStore.addLog(
      `${caster.name}使用好高骛远，${selfCity.name}(${currentHp})被替换为${newCity.name}(${newCity.hp})`
    )

    return {
      success: true,
      message: `城市已强化，${selfCity.name} → ${newCity.name}(HP: ${newCity.hp})`
    }
  }

  /**
   * 狐假虎威 - 伪装城市信息
   */
  function executeHuJiaHuWei(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // 从未使用城市池中筛选HP≥10000的城市作为伪装数据源
    const unusedCities = gameStore.getUnusedCities()
    const highHpCities = unusedCities.filter(city => city.hp >= 10000)

    if (highHpCities.length === 0) {
      return {
        success: false,
        message: '城市池中没有HP≥10000的城市可用于伪装'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('狐假虎威', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 随机选择一个高HP城市作为伪装模板
    const disguiseTemplate = highHpCities[Math.floor(Math.random() * highHpCities.length)]

    // 获取城市索引
    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 初始化disguisedCities
    if (!gameStore.disguisedCities[caster.name]) {
      gameStore.disguisedCities[caster.name] = {}
    }

    // 设置伪装数据（m/cur/n三重HP追踪）
    gameStore.disguisedCities[caster.name][cityIdx] = {
      m: disguiseTemplate.hp,              // 初始伪装HP
      cur: disguiseTemplate.hp,            // 当前伪装HP（会随伤害变化）
      n: selfCity.currentHp || selfCity.hp, // 真实HP（隐藏）
      fakeName: disguiseTemplate.name,     // 伪装名称
      paid: false,                         // 被拆穿时扣9金币标记
      roundsLeft: 3                        // 持续3回合
    }

    // 清除该城市的已知状态（对手不知道这是什么城市）
    gameStore.clearCityKnownStatus(caster.name, cityIdx)

    gameStore.addLog(
      `${caster.name}对${selfCity.name}使用狐假虎威，伪装成${disguiseTemplate.name}(${disguiseTemplate.hp}HP)，持续3回合`
    )

    return {
      success: true,
      message: `${selfCity.name}伪装成${disguiseTemplate.name}，持续3回合`
    }
  }

  /**
   * 抛砖引玉 - HP最低城市禁战，每回合+2金币
   */
  function executePaoZhuanYinYu(caster) {
    const aliveCities = caster.cities.filter(c => c.isAlive && !c.isCenter)

    if (aliveCities.length === 0) {
      return { success: false, message: '没有可用城市' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('抛砖引玉', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const lowestHpCity = aliveCities.reduce((min, city) =>
      (city.currentHp || city.hp) < (min.currentHp || min.hp) ? city : min
    )

    lowestHpCity.modifiers = lowestHpCity.modifiers || []
    lowestHpCity.modifiers.push({
      type: 'forbidden_battle',
      duration: 5,
      goldBonus: 2,
      finalHpMultiplier: 0.2
    })

    gameStore.addLog(`${caster.name}对${lowestHpCity.name}使用抛砖引玉，禁战5回合`)

    return {
      success: true,
      message: `${lowestHpCity.name}禁战5回合，每回合+2金币`
    }
  }

  /**
   * 进制扭曲 - 将HP从八进制转为十进制
   */
  function executeJinZhiNiuQu(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '进制扭曲')) {
      gameStore.addLog(`${caster.name}使用进制扭曲，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('进制扭曲', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取城市索引
    const cityIdx = target.cities.indexOf(targetCity)

    // 检查并消耗保护罩/钢铁护盾
    if (gameStore.consumeProtection(target.name, cityIdx)) {
      gameStore.addLog(`进制扭曲被${target.name}的${targetCity.name}护盾抵消`)
      return {
        success: true,
        message: `效果被护盾抵消`
      }
    }

    const currentHp = targetCity.currentHp || targetCity.hp
    const hpStr = currentHp.toString()

    // 检查是否包含8或9
    if (hpStr.includes('8') || hpStr.includes('9')) {
      return { success: false, message: 'HP中包含8或9，无法使用' }
    }

    // 八进制转十进制
    const newHp = parseInt(hpStr, 8)
    targetCity.currentHp = newHp

    // 检查是否阵亡
    if (newHp <= 0) {
      targetCity.isAlive = false

      // 添加到deadCities列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (cityIdx !== -1 && !gameStore.deadCities[target.name].includes(cityIdx)) {
        gameStore.deadCities[target.name].push(cityIdx)
      }

      gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用进制扭曲，HP从${currentHp}变为${newHp}，城市阵亡`)
    } else {
      gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用进制扭曲，HP从${currentHp}变为${newHp}`)
    }

    return {
      success: true,
      message: `HP从${currentHp}(八进制)变为${newHp}(十进制)`
    }
  }

  /**
   * 提灯定损 - HP除以3
   */
  function executeTiDengDingSun(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    // 不能对中心城市使用
    if (targetCity.isCenter) {
      return { success: false, message: '无法对中心城市使用' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '提灯定损')) {
      gameStore.addLog(`${caster.name}使用提灯定损，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('提灯定损', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取城市索引
    const cityIdx = target.cities.indexOf(targetCity)

    // 检查并消耗保护罩/钢铁护盾
    if (gameStore.consumeProtection(target.name, cityIdx)) {
      gameStore.addLog(`提灯定损被${target.name}的${targetCity.name}护盾抵消`)
      return {
        success: true,
        message: `效果被护盾抵消`
      }
    }

    const currentHp = targetCity.currentHp || targetCity.hp
    const newHp = Math.floor(currentHp / 3)
    targetCity.currentHp = newHp

    // 检查是否阵亡
    if (newHp <= 0) {
      targetCity.isAlive = false

      // 添加到deadCities列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (cityIdx !== -1 && !gameStore.deadCities[target.name].includes(cityIdx)) {
        gameStore.deadCities[target.name].push(cityIdx)
      }

      gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用提灯定损，HP从${currentHp}降至${newHp}，城市阵亡`)
    } else {
      gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用提灯定损，HP从${currentHp}降至${newHp}`)
    }

    return {
      success: true,
      message: `${targetCity.name}的HP降至${newHp}`
    }
  }

  /**
   * 连续打击 - 2个城市HP减半
   */
  function executeLianXuDaJi(caster, target, cityIndices) {
    if (!cityIndices || cityIndices.length !== 2) {
      return { success: false, message: '需要选择2个城市' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '连续打击')) {
      gameStore.addLog(`${caster.name}使用连续打击，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('连续打击', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 筛选有效城市（存活、非中心）
    const validCities = []
    for (const idx of cityIndices) {
      const city = target.cities[idx]
      if (!city || city.isAlive === false || city.isCenter) {
        continue
      }
      validCities.push({ city, idx })
    }

    if (validCities.length !== 2) {
      return { success: false, message: '需要选择2个有效的非中心存活城市' }
    }

    // 对每个城市检查护盾并造成伤害
    const affectedCities = []
    const blockedCities = []

    for (const { city, idx } of validCities) {
      // 检查并消耗保护罩/钢铁护盾
      if (gameStore.consumeProtection(target.name, idx)) {
        blockedCities.push(city.name)
        continue
      }

      // 造成伤害
      const currentHp = city.currentHp || city.hp
      const newHp = Math.floor(currentHp / 2)
      city.currentHp = newHp

      // 检查是否阵亡
      if (newHp <= 0) {
        city.isAlive = false

        // 添加到deadCities列表
        if (!gameStore.deadCities[target.name]) {
          gameStore.deadCities[target.name] = []
        }
        if (!gameStore.deadCities[target.name].includes(idx)) {
          gameStore.deadCities[target.name].push(idx)
        }
      }

      affectedCities.push(city.name)
    }

    // 记录日志
    if (blockedCities.length > 0) {
      gameStore.addLog(`连续打击被${target.name}的${blockedCities.join('、')}护盾抵消`)
    }
    if (affectedCities.length > 0) {
      gameStore.addLog(`${caster.name}对${target.name}的${affectedCities.join('、')}使用连续打击，HP减半`)
    }

    if (affectedCities.length === 0 && blockedCities.length > 0) {
      return {
        success: true,
        message: '所有伤害被护盾抵消'
      }
    }

    return {
      success: true,
      message: `${affectedCities.join('、')}的HP已减半${blockedCities.length > 0 ? `，${blockedCities.join('、')}被护盾保护` : ''}`
    }
  }

  /**
   * 波涛汹涌 - 所有预备沿海城市HP减半，本回合出战沿海城市战斗前再次减半
   * 新版本：预备沿海城市HP减半 + 本回合出战沿海城市战斗前再减半（仅本回合）
   */
  function executeBoTaoXiongYong(caster, target) {
    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '波涛汹涌')) {
      gameStore.addLog(`${caster.name}使用波涛汹涌，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('波涛汹涌', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 第一部分：获取所有预备（roster）中的沿海城市
    const rosterIndices = gameStore.roster[target.name] || []
    const coastalRosterCities = []

    rosterIndices.forEach(idx => {
      const city = target.cities[idx]
      if (city && city.isAlive !== false && city.isCoastal) {
        coastalRosterCities.push({ city, idx })
      }
    })

    // 对预备沿海城市HP减半
    const affectedCities = []
    const blockedCities = []

    for (const { city, idx } of coastalRosterCities) {
      // 检查并消耗保护罩/钢铁护盾
      if (gameStore.consumeProtection(target.name, idx)) {
        blockedCities.push(city.name)
        continue
      }

      // 预备城市HP减半
      const currentHp = city.currentHp || city.hp
      const newHp = Math.floor(currentHp / 2)
      city.currentHp = newHp

      // 检查是否阵亡
      if (newHp <= 0) {
        city.isAlive = false

        // 添加到deadCities列表
        if (!gameStore.deadCities[target.name]) {
          gameStore.deadCities[target.name] = []
        }
        if (!gameStore.deadCities[target.name].includes(idx)) {
          gameStore.deadCities[target.name].push(idx)
        }
      }

      affectedCities.push(city.name)
    }

    // 第二部分：设置本回合出战沿海城市战斗前再次减半的标记
    if (!gameStore.botaoxiongyong) {
      gameStore.botaoxiongyong = {}
    }
    gameStore.botaoxiongyong[target.name] = {
      active: true,
      roundsLeft: 1  // 仅本回合有效
    }

    // 记录日志
    if (blockedCities.length > 0) {
      gameStore.addLog(`波涛汹涌被${target.name}的${blockedCities.join('、')}护盾抵消`)
    }

    const logMessage = affectedCities.length > 0
      ? `${caster.name}对${target.name}使用波涛汹涌，${affectedCities.length}个预备沿海城市HP减半，本回合出战沿海城市战斗前将再次减半`
      : `${caster.name}对${target.name}使用波涛汹涌，本回合出战沿海城市战斗前HP将减半`

    gameStore.addLog(logMessage)

    if (affectedCities.length === 0 && blockedCities.length === 0) {
      return {
        success: true,
        message: '本回合出战沿海城市战斗前HP将减半'
      }
    }

    if (affectedCities.length === 0 && blockedCities.length > 0) {
      return {
        success: true,
        message: '所有预备沿海城市被护盾保护，但本回合出战沿海城市战斗前HP仍将减半'
      }
    }

    return {
      success: true,
      message: `${affectedCities.length}个预备沿海城市HP减半${blockedCities.length > 0 ? `（${blockedCities.length}个被护盾保护）` : ''}，本回合出战沿海城市战斗前将再次减半`
    }
  }

  /**
   * 狂轰滥炸 - 所有非预备城市各受1500伤害
   */
  function executeKuangHongLanZha(caster, target) {
    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '狂轰滥炸')) {
      gameStore.addLog(`${caster.name}使用狂轰滥炸，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('狂轰滥炸', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取所有非预备城市（带索引）
    const nonReadyCities = []
    target.cities.forEach((city, idx) => {
      if (city.isAlive !== false && !city.isInBattle) {
        nonReadyCities.push({ city, idx })
      }
    })

    if (nonReadyCities.length === 0) {
      return { success: false, message: '没有非预备城市' }
    }

    // 对每个城市检查护盾并造成伤害
    let affectedCount = 0
    let blockedCount = 0
    let casualties = 0

    for (const { city, idx } of nonReadyCities) {
      // 检查并消耗保护罩/钢铁护盾
      if (gameStore.consumeProtection(target.name, idx)) {
        blockedCount++
        continue
      }

      // 造成伤害
      const currentHp = city.currentHp || city.hp
      const newHp = Math.max(0, currentHp - 1500)
      city.currentHp = newHp

      // 检查是否阵亡
      if (newHp <= 0) {
        city.isAlive = false
        casualties++

        // 添加到deadCities列表
        if (!gameStore.deadCities[target.name]) {
          gameStore.deadCities[target.name] = []
        }
        if (!gameStore.deadCities[target.name].includes(idx)) {
          gameStore.deadCities[target.name].push(idx)
        }
      }

      affectedCount++
    }

    // 记录日志
    if (blockedCount > 0) {
      gameStore.addLog(`狂轰滥炸被${target.name}的${blockedCount}个城市护盾抵消`)
    }
    if (affectedCount > 0) {
      gameStore.addLog(`${caster.name}对${target.name}的${affectedCount}个非预备城市使用狂轰滥炸，摧毁${casualties}个`)
    }

    if (affectedCount === 0 && blockedCount > 0) {
      return {
        success: true,
        message: '所有伤害被护盾抵消'
      }
    }

    return {
      success: true,
      message: `造成${affectedCount}×1500伤害，摧毁${casualties}个城市${blockedCount > 0 ? `，${blockedCount}个被护盾保护` : ''}`
    }
  }

  /**
   * 横扫一空 - 清除所有敌方城市的技能
   */
  function executeHengSaoYiKong(caster, target) {
    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '横扫一空')) {
      gameStore.addLog(`${caster.name}使用横扫一空，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('横扫一空', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    let count = 0

    target.cities.forEach(city => {
      if (city.red || city.green || city.blue || city.yellow) {
        city.red = 0
        city.green = 0
        city.blue = 0
        city.yellow = 0
        count++
      }
    })

    gameStore.addLog(`${caster.name}对${target.name}使用横扫一空，清除了${count}个城市的所有技能`)

    return {
      success: true,
      message: `清除了${count}个城市的所有技能`
    }
  }

  /**
   * 万箭齐发 - 造成己方总HP的50%伤害
   */
  function executeWanJianQiFa(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '万箭齐发')) {
      gameStore.addLog(`${caster.name}使用万箭齐发，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('万箭齐发', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // ✅ 修复：计算每个城市HP×50%之和，而非总HP×50%
    // PDF规则："己方所有城市同时攻击，造成各自HP一半伤害"
    // 每个城市先计算floor(HP×0.5)，然后求和
    const totalDamage = caster.cities
      .filter(c => c.isAlive !== false)
      .reduce((sum, c) => sum + Math.floor((c.currentHp || c.hp) * 0.5), 0)

    // 获取城市索引
    const cityIdx = target.cities.indexOf(targetCity)

    // 检查并消耗保护罩/钢铁护盾
    if (gameStore.consumeProtection(target.name, cityIdx)) {
      gameStore.addLog(`${caster.name}的万箭齐发击破了${target.name}的${targetCity.name}护盾`)
      return {
        success: true,
        message: `击破了${targetCity.name}的护盾`
      }
    }

    // 造成伤害
    const currentHp = targetCity.currentHp || targetCity.hp
    targetCity.currentHp = Math.max(0, currentHp - totalDamage)

    // 检查是否阵亡
    if (targetCity.currentHp <= 0) {
      targetCity.isAlive = false

      // 添加到deadCities列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (cityIdx !== -1 && !gameStore.deadCities[target.name].includes(cityIdx)) {
        gameStore.deadCities[target.name].push(cityIdx)
      }

      gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用万箭齐发，造成${totalDamage}伤害并摧毁`)
    } else {
      gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用万箭齐发，造成${totalDamage}伤害`)
    }

    return {
      success: true,
      message: `造成${totalDamage}点伤害`
    }
  }

  /**
   * 降维打击 - 替换为同省更低等级城市
   * 特殊版本：直辖市/香港→澳门（11金币）
   */
  function executeJiangWeiDaJi(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    // 不能对澳门使用
    if (targetCity.name === '澳门特别行政区') {
      return { success: false, message: '不能对澳门使用降维打击' }
    }

    // 检查是否为直辖市或香港（特殊版本：11金币→澳门）
    const municipalities = ['北京市', '上海市', '天津市', '重庆市', '香港特别行政区']
    const isMunicipality = municipalities.includes(targetCity.name)

    // 特殊版本：直辖市/香港→澳门（11金币）
    if (isMunicipality) {
      // 检查是否为中心城市
      const cityIdx = target.cities.indexOf(targetCity)
      if (targetCity.isCenter || cityIdx === target.centerIndex) {
        return { success: false, message: '不能对中心城市使用降维打击' }
      }

      // 手动扣除11金币（因为skillCosts中是9金币）
      if (caster.gold < 11) {
        return {
          success: false,
          message: `金币不足（需要11，当前${caster.gold}）`
        }
      }
      caster.gold -= 11

      // 获取澳门城市数据
      const macau = gameStore.getCityByName('澳门特别行政区')
      if (!macau) {
        return { success: false, message: '找不到澳门城市数据' }
      }

      // 创建澳门城市
      const replacementCity = {
        name: '澳门特别行政区',
        hp: macau.hp,
        currentHp: macau.hp,
        baseHp: macau.hp,
        isAlive: true,
        red: macau.red || 0,
        green: macau.green || 0,
        blue: macau.blue || 0,
        yellow: macau.yellow || 0,
        modifiers: []
      }

      // 替换城市
      target.cities[cityIdx] = replacementCity

      // 标记澳门为已使用
      gameStore.markCityAsUsed('澳门特别行政区')

      // 更新initialCities
      if (gameStore.initialCities[target.name] && gameStore.initialCities[target.name][cityIdx]) {
        gameStore.initialCities[target.name][cityIdx] = replacementCity
      }

      gameStore.addLog(
        `对${target.name}使用降维打击（直辖市/香港版，花费11金币），${targetCity.name}被替换为澳门特别行政区(${macau.hp})`
      )

      return {
        success: true,
        message: `${targetCity.name} → 澳门特别行政区(HP: ${macau.hp})`
      }
    }

    // 普通版本：同省更低等级城市（9金币）
    const goldCheck = checkAndDeductGold('降维打击', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取该城市所属省份
    const province = gameStore.getProvinceOfCity(targetCity.name)
    if (!province) {
      return { success: false, message: '无法确定城市所属省份' }
    }

    // 获取同省所有城市
    const provinceCities = province.cities

    // 筛选HP更低且未使用的城市
    const targetHp = targetCity.hp
    const unusedCities = gameStore.getUnusedCities()

    const lowerCities = provinceCities.filter(city => {
      // 必须HP更低
      if (city.hp >= targetHp) return false

      // 必须未被使用
      const isUnused = unusedCities.some(uc => uc.name === city.name)
      return isUnused
    })

    // 如果没有更低等级的城市
    if (lowerCities.length === 0) {
      return {
        success: false,
        message: `${province.name}中没有HP更低的未使用城市`
      }
    }

    // 随机选择一个更低等级的城市
    const newCity = lowerCities[Math.floor(Math.random() * lowerCities.length)]

    // 创建新城市（继承部分属性）
    const replacementCity = {
      name: newCity.name,
      hp: newCity.hp,
      currentHp: newCity.hp,
      baseHp: newCity.hp,
      isAlive: true,
      red: newCity.red || 0,
      green: newCity.green || 0,
      blue: newCity.blue || 0,
      yellow: newCity.yellow || 0,
      modifiers: []
    }

    // 找到原城市在数组中的索引
    const idx = target.cities.indexOf(targetCity)
    if (idx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 替换城市
    target.cities[idx] = replacementCity

    // 标记新城市为已使用
    gameStore.markCityAsUsed(newCity.name)

    // 更新initialCities
    if (gameStore.initialCities[target.name] && gameStore.initialCities[target.name][idx]) {
      gameStore.initialCities[target.name][idx] = replacementCity
    }

    gameStore.addLog(
      `对${target.name}使用降维打击，${targetCity.name}(${targetHp})被替换为${replacementCity.name}(${replacementCity.hp})`
    )

    return {
      success: true,
      message: `${targetCity.name} → ${replacementCity.name}(HP: ${replacementCity.hp})`
    }
  }

  /**
   * 深藏不露 - 每连续5回合未出战自动增加10000HP
   * 参考 citycard_web.html lines 16572-16631
   */
  function executeShenCangBuLu(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    // 获取城市索引
    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 检查城市是否存活
    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '城市已阵亡，无法使用深藏不露' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('深藏不露', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化深藏不露结构
    if (!gameStore.hiddenGrowth[caster.name]) {
      gameStore.hiddenGrowth[caster.name] = {}
    }

    // 设置深藏不露状态
    gameStore.hiddenGrowth[caster.name][cityIdx] = {
      idleRounds: 0,
      active: true,
      everDied: false
    }

    gameStore.addLog(`>>> ${caster.name}对${selfCity.name}使用深藏不露，每连续5回合未出战将自动增加10000HP`)

    return {
      success: true,
      message: `${selfCity.name}每连续5回合未出战将获得10000HP`
    }
  }

  /**
   * 定时爆破 - 3回合后爆炸
   */
  function executeDingShiBaoPo(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    if (targetCity.isCenter) {
      return { success: false, message: '无法对中心城市使用' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '定时爆破')) {
      gameStore.addLog(`${caster.name}使用定时爆破，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('定时爆破', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取城市索引
    const cityIdx = target.cities.indexOf(targetCity)

    // 检查并消耗保护罩/钢铁护盾
    if (gameStore.consumeProtection(target.name, cityIdx)) {
      gameStore.addLog(`定时爆破被${target.name}的${targetCity.name}护盾抵消`)
      return {
        success: true,
        message: `效果被护盾抵消`
      }
    }

    // 在gameStore中设置定时炸弹
    if (!gameStore.timeBombs[target.name]) {
      gameStore.timeBombs[target.name] = {}
    }
    gameStore.timeBombs[target.name][cityIdx] = {
      countdown: 3,
      damage: 500,
      centerDamage: 1000
    }

    gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}放置了定时炸弹`)

    return {
      success: true,
      message: `${targetCity.name}上的炸弹将在3回合后爆炸`
    }
  }

  /**
   * 永久摧毁 - 从城市列表删除（直辖市/特区14金币，其他11金币）
   */
  function executeYongJiuCuiHui(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    if (targetCity.isCenter) {
      return { success: false, message: '无法对中心城市使用' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '永久摧毁')) {
      gameStore.addLog(`${caster.name}使用永久摧毁，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 检查冷却时间（5回合）
    if (gameStore.cooldowns && gameStore.cooldowns[caster.name] &&
        gameStore.cooldowns[caster.name]['永久摧毁'] > 0) {
      const remainingCooldown = gameStore.cooldowns[caster.name]['永久摧毁']
      return {
        success: false,
        message: `永久摧毁冷却中，剩余${remainingCooldown}回合`
      }
    }

    // 检查是否为直辖市或特别行政区（14金币）
    const municipalities = ['北京市', '上海市', '天津市', '重庆市', '香港特别行政区', '澳门特别行政区']
    const isMunicipality = municipalities.includes(targetCity.name)
    const requiredGold = isMunicipality ? 14 : 11

    // 手动金币检查和扣除（因为skillCosts中是11金币）
    if (caster.gold < requiredGold) {
      return {
        success: false,
        message: `金币不足（需要${requiredGold}，当前${caster.gold}）`
      }
    }
    caster.gold -= requiredGold

    // 设置冷却时间（5回合）
    if (!gameStore.cooldowns) {
      gameStore.cooldowns = {}
    }
    if (!gameStore.cooldowns[caster.name]) {
      gameStore.cooldowns[caster.name] = {}
    }
    gameStore.cooldowns[caster.name]['永久摧毁'] = 5

    // 获取城市索引
    const idx = target.cities.indexOf(targetCity)

    // 检查并消耗保护罩/钢铁护盾
    if (gameStore.consumeProtection(target.name, idx)) {
      gameStore.addLog(`${caster.name}的永久摧毁击破了${target.name}的${targetCity.name}护盾${isMunicipality ? '（直辖市/特区，花费14金币）' : ''}`)
      return {
        success: true,
        message: `击破了${targetCity.name}的护盾`
      }
    }

    // 从列表中删除
    target.cities.splice(idx, 1)

    // 从deadCities中移除（如果存在）
    if (gameStore.deadCities[target.name]) {
      const deadIdx = gameStore.deadCities[target.name].indexOf(idx)
      if (deadIdx > -1) {
        gameStore.deadCities[target.name].splice(deadIdx, 1)
      }
      // 更新后续城市的索引（所有大于idx的索引都要减1）
      gameStore.deadCities[target.name] = gameStore.deadCities[target.name]
        .map(i => i > idx ? i - 1 : i)
    }

    gameStore.addLog(`${caster.name}永久摧毁了${target.name}的${targetCity.name}${isMunicipality ? '（直辖市/特区，花费14金币）' : ''}，冷却5回合`)

    return {
      success: true,
      message: `${targetCity.name}已被永久摧毁`
    }
  }

  /**
   * 战略转移 - 更换中心城市
   */
  function executeZhanLueZhuanYi(caster, newCenter) {
    if (!newCenter) {
      return { success: false, message: '未选择新中心城市' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('战略转移', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const oldCenter = caster.cities.find(c => c.isCenter)

    if (oldCenter) {
      oldCenter.isCenter = false
    }

    newCenter.isCenter = true
    const currentHp = newCenter.currentHp || newCenter.hp
    newCenter.currentHp = Math.floor(currentHp * 1.5)

    gameStore.addLog(`${caster.name}使用战略转移，${newCenter.name}成为新中心(HP+50%)`)

    return {
      success: true,
      message: `${newCenter.name}成为新中心，HP+50%`
    }
  }

  /**
   * 连锁反应 - 造成2000伤害，若消灭则溅射1000→500
   */
  function executeLianSuoFanYing(caster, target, targetCity) {
    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '连锁反应')) {
      gameStore.addLog(`${caster.name}使用连锁反应，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('连锁反应', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取城市索引
    const cityIdx = target.cities.indexOf(targetCity)
    if (cityIdx === -1) {
      return { success: false, message: '目标城市不在玩家城市列表中' }
    }

    // 检查并消耗保护罩/钢铁护盾
    if (gameStore.consumeProtection(target.name, cityIdx)) {
      gameStore.addLog(`${caster.name}的连锁反应击破了${target.name}的${targetCity.name}护盾`)
      return {
        success: true,
        message: `击破了${targetCity.name}的护盾`
      }
    }

    // 阶段1：对目标城市造成2000伤害
    const targetName = targetCity.name
    const currentHp = targetCity.currentHp || targetCity.hp
    const newHp = Math.max(0, currentHp - 2000)
    targetCity.currentHp = newHp

    const targetDied = newHp <= 0
    if (targetDied) {
      targetCity.isAlive = false
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (!gameStore.deadCities[target.name].includes(cityIdx)) {
        gameStore.deadCities[target.name].push(cityIdx)
      }
    }

    gameStore.addLog(`${caster.name}对${target.name}的${targetName}使用连锁反应，造成2000伤害${targetDied ? '并阵亡' : `（剩余${Math.floor(newHp)}）`}`)

    // 如果目标未死，直接结束
    if (!targetDied) {
      return {
        success: true,
        message: `${targetName}受到2000伤害`
      }
    }

    // 阶段2：目标已死，对其余出阵城市（roster）造成1000溅射伤害
    const rosterIndices = gameStore.roster[target.name] || []
    const otherRosterCities = rosterIndices
      .filter(idx => idx !== cityIdx && target.cities[idx] && target.cities[idx].isAlive !== false)

    if (otherRosterCities.length === 0) {
      gameStore.addLog(`连锁反应：${targetName}阵亡，但对手无其他出阵城市`)
      return {
        success: true,
        message: `${targetName}阵亡，但对手无其他出阵城市`
      }
    }

    const deadFrom1000 = []
    otherRosterCities.forEach(idx => {
      const city = target.cities[idx]
      const cityName = city.name

      // 检查并消耗保护罩/钢铁护盾
      if (gameStore.consumeProtection(target.name, idx)) {
        gameStore.addLog(`${cityName}的护盾抵消了1000伤害`)
        return
      }

      const cityCurrentHp = city.currentHp || city.hp
      const cityNewHp = Math.max(0, cityCurrentHp - 1000)
      city.currentHp = cityNewHp

      if (cityNewHp <= 0) {
        city.isAlive = false
        if (!gameStore.deadCities[target.name].includes(idx)) {
          gameStore.deadCities[target.name].push(idx)
        }
        deadFrom1000.push(cityName)
      }
    })

    // 如果没有城市因1000伤害阵亡，结束
    if (deadFrom1000.length === 0) {
      const affectedNames = otherRosterCities.map(idx => target.cities[idx].name).join('、')
      gameStore.addLog(`连锁反应：${targetName}阵亡，其余出阵城市（${affectedNames}）各受1000伤害`)
      return {
        success: true,
        message: `${targetName}阵亡，其余出阵城市各受1000伤害`
      }
    }

    // 阶段3：有城市因1000伤害阵亡，对仍存活的出阵城市额外造成500伤害
    const stillAlive = otherRosterCities.filter(idx => target.cities[idx].isAlive !== false)
    const deadFrom500 = []

    stillAlive.forEach(idx => {
      const city = target.cities[idx]
      const cityName = city.name

      // 检查并消耗保护罩/钢铁护盾
      if (gameStore.consumeProtection(target.name, idx)) {
        gameStore.addLog(`${cityName}的护盾抵消了500伤害`)
        return
      }

      const cityCurrentHp = city.currentHp || city.hp
      const cityNewHp = Math.max(0, cityCurrentHp - 500)
      city.currentHp = cityNewHp

      if (cityNewHp <= 0) {
        city.isAlive = false
        if (!gameStore.deadCities[target.name].includes(idx)) {
          gameStore.deadCities[target.name].push(idx)
        }
        deadFrom500.push(cityName)
      }
    })

    gameStore.addLog(
      `连锁反应：${targetName}阵亡，${deadFrom1000.join('、')}因1000伤害阵亡，剩余城市再受500伤害${deadFrom500.length > 0 ? `，${deadFrom500.join('、')}因此阵亡` : ''}`
    )

    return {
      success: true,
      message: `连锁反应完成！${targetName}阵亡，触发两次溅射，共消灭${deadFrom1000.length + deadFrom500.length}个城市`
    }
  }

  /**
   * 招贤纳士 - 抢夺对手HP小于阈值的城市
   */
  function executeZhaoXianNaShi(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '招贤纳士')) {
      gameStore.addLog(`${caster.name}使用招贤纳士，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('招贤纳士', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 找到己方当前HP≤2000的城市
    const myCitiesBelow2000 = caster.cities
      .filter(c => c && c.isAlive !== false && c.hp > 0 && c.hp <= 2000)

    if (myCitiesBelow2000.length === 0) {
      return {
        success: false,
        message: '你没有HP小于等于2000的城市'
      }
    }

    // 随机抽取一座己方城市作为阈值
    const randomIdx = Math.floor(Math.random() * myCitiesBelow2000.length)
    const cityA = myCitiesBelow2000[randomIdx]
    const thresholdHp = cityA.hp

    // 找到对手所有HP低于阈值的城市（排除中心、钢铁、定海神针）
    const targetCities = []
    target.cities.forEach((city, idx) => {
      if (!city || city.isAlive === false) return
      if (city.isCenter) return // 排除中心城市

      // 排除谨慎交换集合中的城市
      if (gameStore.isInCautiousSet(target.name, idx)) return

      // 排除钢铁城市
      if (gameStore.hasIronShield(target.name, idx)) return

      // 排除定海神针城市
      if (gameStore.anchored[target.name] && gameStore.anchored[target.name][idx] > 0) return

      // 检查HP是否小于阈值
      if (city.hp < thresholdHp) {
        targetCities.push({ city, index: idx })
      }
    })

    if (targetCities.length === 0) {
      return {
        success: false,
        message: `${target.name}没有符合条件的城市（HP<${Math.floor(thresholdHp)}且非中心/钢铁/定海神针城市）`
      }
    }

    // 抢夺这些城市
    const capturedNames = []
    for (const item of targetCities) {
      const city = { ...item.city }
      const newIdx = caster.cities.length
      caster.cities.push(city)
      capturedNames.push(city.name)

      // 同步转移initialCities数据
      if (!gameStore.initialCities[caster.name]) {
        gameStore.initialCities[caster.name] = []
      }
      if (gameStore.initialCities[target.name] && gameStore.initialCities[target.name][item.index]) {
        gameStore.initialCities[caster.name].push(gameStore.initialCities[target.name][item.index])
      } else {
        gameStore.initialCities[caster.name].push({ name: city.name, hp: city.hp })
      }

      // 标记城市为已知
      gameStore.setCityKnown(caster.name, newIdx, target.name)

      // 将对手的城市标记为阵亡
      target.cities[item.index].isAlive = false
      target.cities[item.index].currentHp = 0

      // 添加到deadCities列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (!gameStore.deadCities[target.name].includes(item.index)) {
        gameStore.deadCities[target.name].push(item.index)
      }

      // 清除技能等级
      target.cities[item.index].red = 0
      target.cities[item.index].green = 0
      target.cities[item.index].blue = 0
      target.cities[item.index].yellow = 0
    }

    // 如果caster城市数≤5，自动加入roster
    if (caster.cities.length <= 5) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      const startIdx = caster.cities.length - capturedNames.length
      for (let i = startIdx; i < caster.cities.length; i++) {
        if (!gameStore.roster[caster.name].includes(i)) {
          gameStore.roster[caster.name].push(i)
        }
      }
    }

    gameStore.addLog(
      `${caster.name}使用招贤纳士（阈值${Math.floor(thresholdHp)}），抢夺了${target.name}的${capturedNames.length}座城市：${capturedNames.join('、')}`
    )

    return {
      success: true,
      message: `成功抢夺${capturedNames.length}座城市：${capturedNames.join('、')}`
    }
  }

  /**
   * 无懈可击 - 撤回对手最新使用的技能
   */
  function executeWuXieKeJi(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查是否有可以撤回的技能
    const lastSkillUsed = gameStore.lastSkillUsed
    if (!lastSkillUsed) {
      return {
        success: false,
        message: '没有可以撤回的技能'
      }
    }

    // 检查技能是否来自对手且在本回合使用
    if (lastSkillUsed.userName !== target.name || lastSkillUsed.roundNumber !== gameStore.currentRound) {
      return {
        success: false,
        message: '对手本回合没有使用技能'
      }
    }

    // 检查技能是否已被撤回
    if (lastSkillUsed.revoked) {
      return {
        success: false,
        message: '该技能已被撤回'
      }
    }

    // 确定所需金币（1-15金币技能需11金币，16+金币技能需19金币）
    const skillCost = lastSkillUsed.cost || 0
    const requiredCost = skillCost <= 15 ? 11 : 19

    // 金币检查和扣除（使用动态计算的金币数）
    if (caster.gold < requiredCost) {
      return {
        success: false,
        message: `金币不足！撤销此技能需要${requiredCost}金币`
      }
    }

    // 检查对手是否有坚不可摧护盾保护（防止技能被撤回）
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '无懈可击')) {
      gameStore.addLog(`${caster.name}尝试撤回${target.name}的技能"${lastSkillUsed.skillName}"，但被对方的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 检查是否有游戏状态快照
    if (!gameStore.gameStateSnapshot) {
      return {
        success: false,
        message: '无法撤回技能，没有可恢复的游戏状态'
      }
    }

    // 扣除金币
    caster.gold -= requiredCost

    // 恢复游戏状态快照
    const restored = gameStore.restoreGameStateSnapshot()
    if (!restored) {
      return {
        success: false,
        message: '状态恢复失败'
      }
    }

    // 标记技能为已撤回
    gameStore.lastSkillUsed.revoked = true

    gameStore.addLog(
      `${caster.name}使用无懈可击（花费${requiredCost}金币），成功撤回了${target.name}刚使用的技能"${lastSkillUsed.skillName}"`
    )

    return {
      success: true,
      message: `成功撤回了${target.name}的技能"${lastSkillUsed.skillName}"`
    }
  }

  /**
   * 坚不可摧 - 3回合内阻挡40+技能
   */
  function executeJianBuKeCui(caster) {
    // 检查使用次数（每局限2次）
    if (!gameStore.jianbukecuiUsageCount) {
      gameStore.jianbukecuiUsageCount = {}
    }
    if (!gameStore.jianbukecuiUsageCount[caster.name]) {
      gameStore.jianbukecuiUsageCount[caster.name] = 0
    }
    if (gameStore.jianbukecuiUsageCount[caster.name] >= 2) {
      return {
        success: false,
        message: '坚不可摧每局最多使用2次'
      }
    }

    // 检查冷却时间（5回合）
    if (gameStore.cooldowns && gameStore.cooldowns[caster.name] &&
        gameStore.cooldowns[caster.name]['坚不可摧'] > 0) {
      const remainingCooldown = gameStore.cooldowns[caster.name]['坚不可摧']
      return {
        success: false,
        message: `坚不可摧冷却中，剩余${remainingCooldown}回合`
      }
    }

    // 检查是否已有坚不可摧护盾
    if (gameStore.jianbukecui[caster.name] && gameStore.jianbukecui[caster.name].roundsLeft > 0) {
      return {
        success: false,
        message: '已有坚不可摧护盾，无需重复使用'
      }
    }

    // 检查"相同轮次只能有一个玩家拥有护盾"
    const hasActiveShield = Object.keys(gameStore.jianbukecui).some(playerName => {
      return playerName !== caster.name &&
             gameStore.jianbukecui[playerName] &&
             gameStore.jianbukecui[playerName].roundsLeft > 0
    })
    if (hasActiveShield) {
      return {
        success: false,
        message: '相同轮次只能有一个玩家拥有坚不可摧护盾'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('坚不可摧', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 增加使用次数
    gameStore.jianbukecuiUsageCount[caster.name]++

    // 设置冷却时间（5回合）
    if (!gameStore.cooldowns) {
      gameStore.cooldowns = {}
    }
    if (!gameStore.cooldowns[caster.name]) {
      gameStore.cooldowns[caster.name] = {}
    }
    gameStore.cooldowns[caster.name]['坚不可摧'] = 5

    // 设置坚不可摧护盾（持续3回合）
    gameStore.jianbukecui[caster.name] = {
      roundsLeft: 3
    }

    gameStore.addLog(`${caster.name}使用坚不可摧，获得护盾保护，持续3回合（冷却5回合，剩余${2 - gameStore.jianbukecuiUsageCount[caster.name]}次）`)

    return {
      success: true,
      message: `获得坚不可摧护盾，持续3回合，可阻挡40+种攻击技能（剩余${2 - gameStore.jianbukecuiUsageCount[caster.name]}次）`
    }
  }

  /**
   * 移花接木 - 偷取对手使用过的技能（持续3回合）
   */
  function executeYiHuaJieMu(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查使用次数（每局限2次）
    if (!gameStore.yihuajiemuUsageCount) {
      gameStore.yihuajiemuUsageCount = {}
    }
    if (!gameStore.yihuajiemuUsageCount[caster.name]) {
      gameStore.yihuajiemuUsageCount[caster.name] = 0
    }
    if (gameStore.yihuajiemuUsageCount[caster.name] >= 2) {
      return {
        success: false,
        message: '移花接木每局最多使用2次'
      }
    }

    // 检查skillUsageTracking记录
    const targetUsage = gameStore.skillUsageTracking[target.name]
    if (!targetUsage || Object.keys(targetUsage).length < 2) {
      return {
        success: false,
        message: `${target.name}尚未使用足够的技能（需要至少2个不同的非橙卡技能）`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('移花接木', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 筛选非橙卡技能（1-15金币）
    const eligibleSkills = Object.keys(targetUsage).filter(skillName => {
      if (targetUsage[skillName] <= 0) return false

      // 获取技能金币消耗
      const skillCost = SKILL_COSTS[skillName] || 0

      // 只能偷取非橙卡技能（1-15金币）
      return skillCost >= 1 && skillCost <= 15
    })

    if (eligibleSkills.length < 2) {
      return {
        success: false,
        message: `${target.name}尚未使用足够的可偷取技能（需要至少2个非橙卡技能）`
      }
    }

    // 随机抽取一个技能
    const stolenSkill = eligibleSkills[Math.floor(Math.random() * eligibleSkills.length)]

    // 增加使用次数
    gameStore.yihuajiemuUsageCount[caster.name]++

    // 初始化stolenSkills结构（添加到gameStore状态中）
    if (!gameStore.stolenSkills) {
      gameStore.stolenSkills = {}
    }
    if (!gameStore.stolenSkills[caster.name]) {
      gameStore.stolenSkills[caster.name] = []
    }

    gameStore.stolenSkills[caster.name].push({
      skillName: stolenSkill,
      roundsLeft: 3,
      usedCount: 0,
      from: target.name
    })

    const remainingUses = 2 - gameStore.yihuajiemuUsageCount[caster.name]
    gameStore.addLog(
      `${caster.name}对${target.name}使用了移花接木，偷取了技能"${stolenSkill}"（可在接下来3回合内使用，剩余${remainingUses}次）`
    )

    return {
      success: true,
      message: `成功偷取了${target.name}的"${stolenSkill}"技能，可在接下来3回合使用（剩余${remainingUses}次）`
    }
  }

  /**
   * 不露踪迹 - 隐藏技能使用情况（持续3回合）
   */
  function executeBuLuZongJi(caster) {
    // 检查是否已处于不露踪迹状态
    if (gameStore.stealth && gameStore.stealth[caster.name] && gameStore.stealth[caster.name].roundsLeft > 0) {
      return {
        success: false,
        message: '已处于不露踪迹状态'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('不露踪迹', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化stealth结构
    if (!gameStore.stealth) {
      gameStore.stealth = {}
    }

    gameStore.stealth[caster.name] = {
      roundsLeft: 3
    }

    gameStore.addLog(`${caster.name}使用了不露踪迹，接下来3回合技能使用情况将对其他玩家隐藏`)

    return {
      success: true,
      message: '进入不露踪迹状态，持续3回合'
    }
  }

  /**
   * 整齐划一 - 将对手战斗预备城市HP向下取整到万位数
   */
  function executeZhengQiHuaYi(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '整齐划一')) {
      gameStore.addLog(`${caster.name}使用整齐划一，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('整齐划一', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取对手的战斗预备城市（roster）
    const rosterIndices = gameStore.roster[target.name] || []
    if (rosterIndices.length === 0) {
      return {
        success: false,
        message: '对手没有战斗预备城市'
      }
    }

    const affectedCities = []

    for (const cityIdx of rosterIndices) {
      const city = target.cities[cityIdx]
      if (!city || city.isAlive === false) continue

      const originalHp = city.currentHp || city.hp
      let newHp

      if (originalHp < 10000) {
        // 低于10000的一律取到3000
        newHp = 3000
      } else {
        // 向下取整到最近的万位数
        newHp = Math.floor(originalHp / 10000) * 10000
      }

      city.currentHp = newHp
      affectedCities.push(`${city.name}(${Math.floor(originalHp)}→${Math.floor(newHp)})`)
    }

    if (affectedCities.length > 0) {
      gameStore.addLog(
        `${caster.name}对${target.name}使用了整齐划一，受影响城市：${affectedCities.join('、')}`
      )
    } else {
      gameStore.addLog(`${caster.name}对${target.name}使用了整齐划一，但没有城市受影响`)
    }

    return {
      success: true,
      message: `${affectedCities.length}个战斗预备城市受到影响`
    }
  }

  /**
   * 人质交换 - 交换双方特定位置的战斗预备城市
   */
  function executeRenZhiJiaoHuan(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查双方城市数
    if (caster.cities.length < 4 || target.cities.length < 4) {
      return {
        success: false,
        message: '双方城市数都需要≥4才能使用人质交换'
      }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '人质交换')) {
      gameStore.addLog(`${caster.name}使用人质交换，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('人质交换', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取战斗预备城市（roster）
    const myRoster = gameStore.roster[caster.name] || []
    const oppRoster = gameStore.roster[target.name] || []

    if (myRoster.length < 4) {
      return {
        success: false,
        message: `你的战斗预备城市不足4个（当前${myRoster.length}个）`
      }
    }

    if (oppRoster.length < 3) {
      return {
        success: false,
        message: `对方的战斗预备城市不足3个（当前${oppRoster.length}个）`
      }
    }

    // 按HP排序战斗预备城市（降序）
    const myRosterSorted = myRoster
      .map(idx => ({
        idx,
        hp: (caster.cities[idx].currentHp || caster.cities[idx].hp)
      }))
      .sort((a, b) => b.hp - a.hp)

    const oppRosterSorted = oppRoster
      .map(idx => ({
        idx,
        hp: (target.cities[idx].currentHp || target.cities[idx].hp)
      }))
      .sort((a, b) => b.hp - a.hp)

    // 我方选择HP第4的城市
    const myCityIdx = myRosterSorted[3].idx
    const myCity = caster.cities[myCityIdx]

    // 对方选择HP第3的城市（排除谨慎交换集合）
    let oppCityIdx = -1
    for (let i = 0; i < oppRosterSorted.length; i++) {
      const idx = oppRosterSorted[i].idx
      if (!gameStore.isInCautiousSet(target.name, idx)) {
        // 找到第3个不在谨慎交换集合中的城市
        if (i >= 2) {
          oppCityIdx = idx
          break
        }
      }
    }

    // 如果没找到，使用默认第3个
    if (oppCityIdx === -1) {
      if (oppRosterSorted.length < 3) {
        return {
          success: false,
          message: '对方没有足够的可交换战斗预备城市'
        }
      }
      oppCityIdx = oppRosterSorted[2].idx
    }

    const oppCity = target.cities[oppCityIdx]

    // 执行城市交换
    const temp = caster.cities[myCityIdx]
    caster.cities[myCityIdx] = target.cities[oppCityIdx]
    target.cities[oppCityIdx] = temp

    // 同步交换initialCities
    if (gameStore.initialCities[caster.name] && gameStore.initialCities[target.name]) {
      const tempInitial = gameStore.initialCities[caster.name][myCityIdx]
      gameStore.initialCities[caster.name][myCityIdx] = gameStore.initialCities[target.name][oppCityIdx]
      gameStore.initialCities[target.name][oppCityIdx] = tempInitial
    }

    // 标记城市为已知
    gameStore.setCityKnown(caster.name, myCityIdx, target.name)
    gameStore.setCityKnown(target.name, oppCityIdx, caster.name)

    gameStore.addLog(
      `${caster.name}对${target.name}使用了人质交换，交换了${myCity.name}和${oppCity.name}`
    )

    return {
      success: true,
      message: `成功交换了${myCity.name}和${oppCity.name}`
    }
  }

  /**
   * 釜底抽薪 - 使对手下次8+金币技能费用增加50%
   */
  function executeFuDiChouXin(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '釜底抽薪')) {
      gameStore.addLog(`${caster.name}使用釜底抽薪，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('釜底抽薪', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化costIncrease结构
    if (!gameStore.costIncrease) {
      gameStore.costIncrease = {}
    }

    // 设置目标玩家的费用增加标记
    gameStore.costIncrease[target.name] = 1

    gameStore.addLog(
      `${caster.name}对${target.name}使用了釜底抽薪，${target.name}下一次使用8金币及以上技能时费用增加50%`
    )

    return {
      success: true,
      message: `${target.name}下次使用高级技能（8+金币）时费用将增加50%`
    }
  }

  /**
   * 金融危机 - 全部玩家获得2金币，接下来3回合金币最高的玩家无法获得自动+3金币，其余玩家只能+1金币
   */
  function executeJinRongWeiJi(caster) {
    // 检查是否已在金融危机期间
    if (gameStore.financialCrisis && gameStore.financialCrisis.roundsLeft > 0) {
      return {
        success: false,
        message: `当前还有${gameStore.financialCrisis.roundsLeft}回合处于金融危机状态，不能再次使用！`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('金融危机', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 全部玩家立即获得2金币
    gameStore.players.forEach(player => {
      player.gold = Math.min(24, player.gold + 2)
    })

    // 设置金融危机状态（持续3回合）
    gameStore.financialCrisis = { roundsLeft: 3 }

    gameStore.addLog(`${caster.name}使用了金融危机，全部玩家获得2金币，接下来3回合金币最高的玩家无法获得自动+3金币，其余玩家只能+1金币`)

    return {
      success: true,
      message: '金融危机生效！全部玩家获得2金币，接下来3回合金币收入受限'
    }
  }

  /**
   * 劫富济贫 - 找出对手血量最高的3座城市和自己血量最低的3座城市，各随机选1座，将两座城市的血量平均化
   */
  function executeJieFuJiPin(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查双方城市数量是否>=5
    const myCities = caster.cities.filter(c => c && (c.currentHp || c.hp) > 0)
    const targetCities = target.cities.filter(c => c && (c.currentHp || c.hp) > 0)

    if (myCities.length < 5) {
      return { success: false, message: `${caster.name}的城市数量不足5座（当前${myCities.length}座）` }
    }
    if (targetCities.length < 5) {
      return { success: false, message: `${target.name}的城市数量不足5座（当前${targetCities.length}座）` }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('劫富济贫', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 找出对方HP前三的城市
    const targetTop3 = target.cities
      .map((c, i) => ({ city: c, index: i, hp: c.currentHp || c.hp || 0 }))
      .filter(item => item.hp > 0)
      .sort((a, b) => b.hp - a.hp)
      .slice(0, 3)

    // 找出己方HP后三的城市
    const myBottom3 = caster.cities
      .map((c, i) => ({ city: c, index: i, hp: c.currentHp || c.hp || 0 }))
      .filter(item => item.hp > 0)
      .sort((a, b) => a.hp - b.hp)
      .slice(0, 3)

    if (targetTop3.length === 0 || myBottom3.length === 0) {
      return { success: false, message: '没有足够的城市可供选择' }
    }

    // 随机选择一座对方城市和一座己方城市
    const targetCity = targetTop3[Math.floor(Math.random() * targetTop3.length)]
    const myCity = myBottom3[Math.floor(Math.random() * myBottom3.length)]

    // 计算平均HP
    const avgHp = Math.round((targetCity.hp + myCity.hp) / 2)

    // 设置HP
    targetCity.city.currentHp = avgHp
    targetCity.city.hp = avgHp
    myCity.city.currentHp = avgHp
    myCity.city.hp = avgHp

    gameStore.addLog(
      `${caster.name}使用劫富济贫，${target.name}的${targetCity.city.name}（原HP:${Math.round(targetCity.hp)}）与${caster.name}的${myCity.city.name}（原HP:${Math.round(myCity.hp)}）HP取平均，均变为${avgHp}`
    )

    return {
      success: true,
      message: `${targetCity.city.name}和${myCity.city.name}的HP均变为${avgHp}`
    }
  }

  /**
   * 改弦更张 - 重新选择战斗预备城市
   */
  function executeGaiXianGengZhang(caster) {
    const mode = gameStore.gameMode || '2P'
    const minCities = (mode === '2v2') ? 4 : 5

    if (caster.cities.length < minCities) {
      return {
        success: false,
        message: `城市数量不足！需要至少${minCities}个城市才能使用改弦更张`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('改弦更张', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 清空当前预备城市列表
    if (!gameStore.roster) {
      gameStore.roster = {}
    }
    gameStore.roster[caster.name] = []

    // 设置需要补充预备城市的标记
    if (!gameStore.playerStates[caster.name]) {
      gameStore.playerStates[caster.name] = {}
    }
    gameStore.playerStates[caster.name].needsRosterRefill = true
    gameStore.playerStates[caster.name].rosterRefillReason = '改弦更张'

    gameStore.addLog(`${caster.name}使用了改弦更张，需要重新选择战斗预备城市`)

    return {
      success: true,
      message: '战斗预备城市已清空，请重新选择'
    }
  }

  /**
   * 城市试炼 (4金币) - HP≤15000的非中心城市试炼3回合，若强制出战则自毁
   */
  function executeChengShiShiLian(caster, selfCity) {
    const targetCityIdx = caster.cities.indexOf(selfCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '城市不存在' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '该城市已阵亡，无法使用城市试炼！' }
    }

    // 检查不能对中心城市使用
    const centerIdx = caster.centerIndex ?? 0
    if (targetCityIdx === centerIdx) {
      return { success: false, message: '无法对中心城市使用城市试炼！' }
    }

    // 检查HP是否≤15000
    const currentHp = selfCity.currentHp || selfCity.hp
    if (currentHp > 15000) {
      return {
        success: false,
        message: `城市试炼仅限当前血量≤15000的城市使用。${selfCity.name}当前为${Math.floor(currentHp)}`
      }
    }

    // 检查冷却时间
    if (!gameStore.cooldowns) {
      gameStore.cooldowns = {}
    }
    if (!gameStore.cooldowns[caster.name]) {
      gameStore.cooldowns[caster.name] = {}
    }
    if (gameStore.cooldowns[caster.name]['城市试炼'] > 0) {
      const remainingCooldown = gameStore.cooldowns[caster.name]['城市试炼']
      return {
        success: false,
        message: `城市试炼冷却中，剩余${remainingCooldown}回合`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('城市试炼', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 设置冷却时间（5回合）
    gameStore.cooldowns[caster.name]['城市试炼'] = 5

    // 初始化试炼场结构
    if (!gameStore.cityTrialField) {
      gameStore.cityTrialField = {}
    }
    if (!gameStore.cityTrialField[caster.name]) {
      gameStore.cityTrialField[caster.name] = {}
    }

    // 记录试炼信息
    gameStore.cityTrialField[caster.name][targetCityIdx] = {
      originalHp: currentHp,
      roundsLeft: 3,
      startRound: gameStore.currentRound,
      selfDestructOnDeploy: true  // 若强制出战则自毁
    }

    gameStore.addLog(
      `${caster.name}对${selfCity.name}使用了城市试炼，该城市进入试炼3回合，出来后HP×3（若强制出战则自毁）`
    )

    return {
      success: true,
      message: `${selfCity.name}进入试炼，3回合后HP×3（若强制出战则自毁）`
    }
  }

  /**
   * 天灾人祸 - 选择对手已知城市，使其攻击力变为1，持续2回合
   */
  function executeTianZaiRenHuo(caster, target, targetCity) {
    if (!target || !targetCity) {
      return { success: false, message: '未选择目标' }
    }

    const targetCityIdx = target.cities.indexOf(targetCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '城市不存在' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities) {
      gameStore.knownCities = {}
    }
    if (!gameStore.knownCities[caster.name]) {
      gameStore.knownCities[caster.name] = {}
    }
    if (!gameStore.knownCities[caster.name][target.name]) {
      gameStore.knownCities[caster.name][target.name] = []
    }
    if (!gameStore.knownCities[caster.name][target.name].includes(targetCityIdx)) {
      return { success: false, message: '该城市尚未已知，无法使用天灾人祸' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '天灾人祸')) {
      gameStore.addLog(`${caster.name}使用天灾人祸，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('天灾人祸', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化结构
    if (!gameStore.disasterDebuff) {
      gameStore.disasterDebuff = {}
    }
    if (!gameStore.disasterDebuff[target.name]) {
      gameStore.disasterDebuff[target.name] = {}
    }

    // 设置天灾人祸效果：攻击力变为1，持续2回合
    gameStore.disasterDebuff[target.name][targetCityIdx] = 2

    gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用了天灾人祸，该城市攻击力变为1，持续2回合`)

    return {
      success: true,
      message: `${targetCity.name}的攻击力变为1，持续2回合`
    }
  }

  /**
   * 李代桃僵 - 本轮被时来运转或人质交换时可自选交换城市
   */
  function executeLiDaiTaoJiang(caster) {
    // 检查本轮是否已使用
    if (!gameStore.ldtj) {
      gameStore.ldtj = {}
    }
    if (gameStore.ldtj[caster.name]) {
      return { success: false, message: '本轮已经使用过李代桃僵！' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('李代桃僵', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 设置李代桃僵标记（本回合有效）
    gameStore.ldtj[caster.name] = true

    gameStore.addLog(`${caster.name}使用了李代桃僵，本轮被时来运转或人质交换时可以自己选择交换的城市`)

    return {
      success: true,
      message: '李代桃僵生效！本轮被动交换时可自己选择城市'
    }
  }

  /**
   * 避而不见 - 选择对手的一座已知战斗预备城市下场3回合无法出战
   */
  function executeBiErBuJian(caster, target, targetCity) {
    if (!target || !targetCity) {
      return { success: false, message: '未选择目标' }
    }

    // 检查对方存活城市数
    const oppAliveCities = target.cities.filter(c => c && (c.currentHp || c.hp) > 0)
    if (oppAliveCities.length < 2) {
      return {
        success: false,
        message: `对方存活城市数不足2个（当前${oppAliveCities.length}个），无法使用避而不见！`
      }
    }

    const targetCityIdx = target.cities.indexOf(targetCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '城市不存在' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
        !gameStore.knownCities[caster.name][target.name] ||
        !gameStore.knownCities[caster.name][target.name].includes(targetCityIdx)) {
      return { success: false, message: '该城市尚未已知，无法使用避而不见' }
    }

    // 检查是否在对方战斗预备中
    const oppRoster = gameStore.roster[target.name] || []
    if (!oppRoster.includes(targetCityIdx)) {
      return { success: false, message: '该城市不在对方战斗预备中，无法使用避而不见' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '避而不见')) {
      gameStore.addLog(`${caster.name}使用避而不见，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('避而不见', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 根据对方城市数决定持续回合数
    const duration = oppAliveCities.length === 2 ? 2 : 3

    // 初始化结构
    if (!gameStore.forcedBench) {
      gameStore.forcedBench = {}
    }
    if (!gameStore.forcedBench[target.name]) {
      gameStore.forcedBench[target.name] = {}
    }

    // 设置避而不见效果
    gameStore.forcedBench[target.name][targetCityIdx] = duration

    gameStore.addLog(`${caster.name}对${target.name}的${targetCity.name}使用了避而不见，该城市${duration}回合无法出战`)

    return {
      success: true,
      message: `${targetCity.name}将${duration}回合无法出战`
    }
  }

  /**
   * 一触即发 - 选择一个冷却中的技能，将其冷却剩余回合清零
   * 用户需要选择一个正在冷却的技能
   * 效果：将该技能的冷却时间清零
   */
  function executeYiChuJiFa(caster, skillName) {
    // 如果没有提供技能名称，返回需要选择
    if (!skillName) {
      // 获取所有冷却中的技能
      const coolingSkills = []

      if (gameStore.cooldowns && gameStore.cooldowns[caster.name]) {
        const myCooldowns = gameStore.cooldowns[caster.name]
        for (const [name, rounds] of Object.entries(myCooldowns)) {
          if (rounds > 0) {
            coolingSkills.push({
              name: name,
              remainingRounds: rounds
            })
          }
        }
      }

      if (coolingSkills.length === 0) {
        return {
          success: false,
          message: '当前没有冷却中的技能！'
        }
      }

      return {
        success: false,
        message: '请选择要清除冷却的技能',
        needSelection: true,
        data: {
          coolingSkills: coolingSkills
        }
      }
    }

    // 检查技能是否在冷却中
    const cooldownRemaining = gameStore.getSkillCooldown(caster.name, skillName)
    if (cooldownRemaining <= 0) {
      return {
        success: false,
        message: `${skillName}没有在冷却中`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('一触即发', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 清零冷却
    gameStore.clearSkillCooldown(caster.name, skillName)

    gameStore.addLog(`${caster.name}使用了一触即发，${skillName}的冷却已清零（原剩余${cooldownRemaining}回合）`)

    return {
      success: true,
      message: `${skillName}的冷却已清零，可以立即使用`
    }
  }

  /**
   * 技能保护 - 接下来10回合对手无法使用事半功倍、过河拆桥技能
   */
  function executeJiNengBaoHu(caster) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('技能保护', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化结构
    if (!gameStore.skillProtection) {
      gameStore.skillProtection = {}
    }

    // 设置技能保护
    gameStore.skillProtection[caster.name] = { roundsLeft: 10 }

    gameStore.addLog(`${caster.name}使用了技能保护，接下来10回合对手无法使用事半功倍、过河拆桥技能`)

    return {
      success: true,
      message: '技能保护生效！对手10回合内无法使用特定技能'
    }
  }

  /**
   * 突破瓶颈 - 选定一个已达到使用上限的技能，增加一次使用次数上限
   * 用户需要选择一个已经有使用记录的技能
   * 效果：该技能的已使用次数-1（等同于上限+1）
   */
  function executeTuPoPingJing(caster, skillName) {
    // 如果没有提供技能名称，返回需要选择
    if (!skillName) {
      // 获取所有已使用过的技能
      const usedSkills = []

      if (gameStore.skillUsageTracking && gameStore.skillUsageTracking[caster.name]) {
        const myTracking = gameStore.skillUsageTracking[caster.name]
        for (const [name, count] of Object.entries(myTracking)) {
          if (count > 0) {
            usedSkills.push({
              name: name,
              usedCount: count
            })
          }
        }
      }

      if (usedSkills.length === 0) {
        return {
          success: false,
          message: '你还没有使用过任何有次数限制的技能！'
        }
      }

      return {
        success: false,
        message: '请选择要突破瓶颈的技能',
        needSelection: true,
        data: {
          usedSkills: usedSkills
        }
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('突破瓶颈', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 减少使用次数计数（相当于增加可用次数）
    const success = gameStore.decreaseSkillUsageCount(caster.name, skillName)

    if (!success) {
      // 退还金币
      caster.gold += goldCheck.cost
      return {
        success: false,
        message: `${skillName}没有使用记录，无法突破瓶颈`
      }
    }

    gameStore.addLog(`${caster.name}使用了突破瓶颈，${skillName}的使用次数上限+1`)

    return {
      success: true,
      message: `${skillName}使用次数上限已增加1次`
    }
  }

  /**
   * 血量存储 - 创建HP存储库，充值和提取HP
   */
  function executeXueLiangCunChu(caster, selfCity, operation, amount) {
    // 初始化存储库
    if (!gameStore.hpBank) {
      gameStore.hpBank = {}
    }
    if (!gameStore.hpBank[caster.name]) {
      gameStore.hpBank[caster.name] = {
        balance: 0,
        depositMade: false,
        hasWithdrawnThisRound: false
      }
    }

    const bankData = gameStore.hpBank[caster.name]

    // 操作类型：deposit（存款）或 withdraw（取款）
    if (operation === 'deposit') {
      if (bankData.depositMade) {
        return { success: false, message: '已经完成过储值，无法重复储值！（每局限1次）' }
      }

      if (!selfCity) {
        return { success: false, message: '未选择城市' }
      }

      const currentHp = selfCity.currentHp || selfCity.hp
      if (currentHp <= 10000) {
        return { success: false, message: 'HP必须大于10000才能储值！' }
      }

      // 检查存款金额（至少10000）
      if (!amount || amount < 10000) {
        return { success: false, message: '存款金额至少10000HP！' }
      }

      if (amount > currentHp) {
        return { success: false, message: `城市HP不足（当前${Math.floor(currentHp)}，需要${amount}）` }
      }

      // 金币检查和扣除
      const goldCheck = checkAndDeductGold('血量存储', caster, gameStore)
      if (!goldCheck.success) {
        return goldCheck
      }

      // 扣除指定HP并储值
      selfCity.currentHp = (selfCity.currentHp || selfCity.hp) - amount
      bankData.balance = amount
      bankData.depositMade = true

      gameStore.addLog(`${caster.name}使用血量存储，${selfCity.name}扣除${amount}HP并储值到存储库（每局限1次）`)

      return {
        success: true,
        message: `成功储值${amount}HP到存储库，${selfCity.name}当前HP：${Math.floor(selfCity.currentHp)}`
      }
    } else if (operation === 'withdraw') {
      if (!bankData.depositMade) {
        return { success: false, message: '尚未完成储值，无法提取！' }
      }

      if (bankData.hasWithdrawnThisRound) {
        return { success: false, message: '本回合已经提取过，每回合只能提取一次！' }
      }

      // 检查余额是否低于2000（自动销毁）
      if (bankData.balance < 2000) {
        delete gameStore.hpBank[caster.name]
        return { success: false, message: '存储库余额低于2000，已自动销毁！' }
      }

      if (!selfCity) {
        return { success: false, message: '未选择城市' }
      }

      if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
        return { success: false, message: '该城市已阵亡，无法提取HP！' }
      }

      // 检查提取金额（不少于2000）
      if (!amount || amount < 2000) {
        return { success: false, message: '提取金额不少于2000HP！' }
      }

      if (amount > bankData.balance) {
        return { success: false, message: `存储库余额不足（当前${Math.floor(bankData.balance)}，需要${amount}）` }
      }

      // 提取指定HP
      selfCity.currentHp = (selfCity.currentHp || selfCity.hp) + amount
      bankData.balance -= amount
      bankData.hasWithdrawnThisRound = true

      gameStore.addLog(`${caster.name}从存储库提取${amount}HP到${selfCity.name}，剩余余额：${Math.floor(bankData.balance)}`)

      // 检查提取后余额是否低于2000（自动销毁）
      if (bankData.balance < 2000) {
        delete gameStore.hpBank[caster.name]
        gameStore.addLog(`${caster.name}的存储库余额低于2000，已自动销毁`)
      }

      return {
        success: true,
        message: `成功提取${amount}HP，存储库剩余：${Math.floor(bankData.balance)}`,
        data: {
          withdrawn: amount,
          remaining: bankData.balance
        }
      }
    } else if (operation === 'applyInterest') {
      // 利息计算（每回合自动调用）
      if (!bankData.depositMade || bankData.balance <= 0) {
        return { success: true, message: '无活跃存储库' }
      }

      let interestRate = 0
      if (bankData.balance < 50000) {
        interestRate = 0.10  // 10%
      } else if (bankData.balance < 100000) {
        interestRate = 0.05  // 5%
      } else {
        interestRate = 0.01  // 1%
      }

      const interest = Math.floor(bankData.balance * interestRate)
      bankData.balance += interest

      gameStore.addLog(`${caster.name}的存储库获得${interest}HP利息（利率${(interestRate * 100).toFixed(0)}%），当前余额：${Math.floor(bankData.balance)}`)

      return {
        success: true,
        message: `获得${interest}HP利息`,
        data: {
          interest: interest,
          balance: bankData.balance
        }
      }
    }

    return { success: false, message: '未知操作类型' }
  }

  /**
   * 海市蜃楼 - 创造中心投影，拦截对中心的伤害（仅2P/2v2）
   */
  function executeHaiShiShenLou(caster) {
    const gameMode = gameStore.gameMode || '2P'
    const is2p = (gameMode === '2P' || gameMode === '2v2')

    if (!is2p) {
      return { success: false, message: '此技能仅限2人/2v2模式使用！' }
    }

    // 检查使用次数（每局限1次）
    if (!gameStore.mirageUsageCount) {
      gameStore.mirageUsageCount = {}
    }
    if (gameStore.mirageUsageCount[caster.name]) {
      return {
        success: false,
        message: '海市蜃楼每局只能使用1次'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('海市蜃楼', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 标记已使用
    gameStore.mirageUsageCount[caster.name] = true

    // 创建中心投影
    if (!gameStore.mirage) {
      gameStore.mirage = {}
    }

    gameStore.mirage[caster.name] = {
      roundsLeft: 5,
      blocked: 0,  // 拦截计数
      active: true
    }

    gameStore.addLog(
      `${caster.name}使用了海市蜃楼，创建中心投影，持续5回合（75%概率拦截对中心的伤害）`
    )

    return {
      success: true,
      message: '海市蜃楼使用成功！中心投影已创建，持续5回合'
    }
  }

  /**
   * 解除封锁 - 解除被禁用的技能
   */
  function executeJieChuFengSuo(caster, skillName) {
    // 收集所有被禁用的技能
    const bannedSkillsSet = new Set()

    // 事半功倍禁用的技能
    if (gameStore.bannedSkills && gameStore.bannedSkills[caster.name]) {
      Object.keys(gameStore.bannedSkills[caster.name]).forEach(skill => bannedSkillsSet.add(skill))
    }

    // 过河拆桥禁用的技能
    if (gameStore.burnBridge) {
      for (const otherPlayerName in gameStore.burnBridge) {
        if (otherPlayerName === caster.name) continue

        const burnBridgeState = gameStore.burnBridge[otherPlayerName]
        if (burnBridgeState && burnBridgeState.bannedSkills) {
          // 检查2v2队友
          let isTeammate = false
          if (gameStore.gameMode === '2v2') {
            const otherPlayer = gameStore.players.find(p => p.name === otherPlayerName)
            if (otherPlayer && caster.team !== undefined && otherPlayer.team !== undefined) {
              isTeammate = caster.team === otherPlayer.team
            }
          }

          if (!isTeammate) {
            burnBridgeState.bannedSkills.forEach(skill => bannedSkillsSet.add(skill))
          }
        }
      }
    }

    // 强制搬运禁用的技能
    if (gameStore.forcedSoldierBan) {
      for (const otherPlayerName in gameStore.forcedSoldierBan) {
        if (otherPlayerName === caster.name) continue

        const banData = gameStore.forcedSoldierBan[otherPlayerName]
        if (banData && banData.bannedSkills) {
          // 检查2v2队友
          let isTeammate = false
          if (gameStore.gameMode === '2v2') {
            const otherPlayer = gameStore.players.find(p => p.name === otherPlayerName)
            if (otherPlayer && caster.team !== undefined && otherPlayer.team !== undefined) {
              isTeammate = caster.team === otherPlayer.team
            }
          }

          if (!isTeammate) {
            banData.bannedSkills.forEach(skill => bannedSkillsSet.add(skill))
          }
        }
      }
    }

    const bannedSkills = Array.from(bannedSkillsSet)

    if (bannedSkills.length === 0) {
      return { success: false, message: '当前没有被禁用的技能！' }
    }

    // 如果没有指定技能，返回列表让前端选择
    if (!skillName) {
      return {
        success: true,
        message: '请选择要解除禁用的技能',
        data: {
          bannedSkills: bannedSkills,
          needSelection: true
        }
      }
    }

    // 检查技能是否在禁用列表中
    if (!bannedSkills.includes(skillName)) {
      return { success: false, message: '该技能未被禁用！' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('解除封锁', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 从各个禁用源中移除该技能
    if (gameStore.bannedSkills && gameStore.bannedSkills[caster.name]) {
      delete gameStore.bannedSkills[caster.name][skillName]
    }

    if (gameStore.burnBridge) {
      for (const otherPlayerName in gameStore.burnBridge) {
        const burnBridgeState = gameStore.burnBridge[otherPlayerName]
        if (burnBridgeState && burnBridgeState.bannedSkills) {
          const index = burnBridgeState.bannedSkills.indexOf(skillName)
          if (index !== -1) {
            burnBridgeState.bannedSkills.splice(index, 1)
          }
        }
      }
    }

    if (gameStore.forcedSoldierBan) {
      for (const otherPlayerName in gameStore.forcedSoldierBan) {
        const banData = gameStore.forcedSoldierBan[otherPlayerName]
        if (banData && banData.bannedSkills) {
          const index = banData.bannedSkills.indexOf(skillName)
          if (index !== -1) {
            banData.bannedSkills.splice(index, 1)
          }
        }
      }
    }

    gameStore.addLog(`${caster.name}使用了解除封锁，${skillName}的禁用状态已解除`)

    return {
      success: true,
      message: `${skillName}的禁用状态已解除`
    }
  }

  /**
   * 数位反转 - 将城市当前HP数字顺序反转（如果末位是0，反转后舍去）
   */
  function executeShuWeiFanZhuan(caster, targetPlayer, targetCity) {
    if (!targetPlayer || !targetCity) {
      return { success: false, message: '未选择目标' }
    }

    const targetCityIdx = targetPlayer.cities.indexOf(targetCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '城市不存在' }
    }

    const currentHp = targetCity.currentHp || targetCity.hp

    // 检查HP是否为80000或100000
    if (currentHp === 80000 || currentHp === 100000) {
      return { success: false, message: '无法对HP为80000或100000的城市使用数位反转' }
    }

    // 如果目标是对手城市，检查是否已知
    if (targetPlayer.name !== caster.name) {
      if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
          !gameStore.knownCities[caster.name][targetPlayer.name] ||
          !gameStore.knownCities[caster.name][targetPlayer.name].includes(targetCityIdx)) {
        return { success: false, message: '该城市尚未已知，无法使用数位反转' }
      }

      // 检查坚不可摧护盾
      if (gameStore.isBlockedByJianbukecui(targetPlayer.name, caster.name, '数位反转')) {
        gameStore.addLog(`${caster.name}使用数位反转，但被${targetPlayer.name}的坚不可摧护盾阻挡`)
        return {
          success: false,
          message: `被${targetPlayer.name}的坚不可摧护盾阻挡`
        }
      }
    }

    // 检查使用次数（每局限1次）
    if (!gameStore.shuweifanzhuanUsageCount) {
      gameStore.shuweifanzhuanUsageCount = {}
    }
    if (gameStore.shuweifanzhuanUsageCount[caster.name] >= 1) {
      return {
        success: false,
        message: '数位反转每局限1次'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('数位反转', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 增加使用次数
    if (!gameStore.shuweifanzhuanUsageCount[caster.name]) {
      gameStore.shuweifanzhuanUsageCount[caster.name] = 0
    }
    gameStore.shuweifanzhuanUsageCount[caster.name]++

    // 反转HP数字（如果末位是0，反转后舍去 - parseInt自动处理前导0）
    const hpString = Math.floor(currentHp).toString()
    const reversedString = hpString.split('').reverse().join('')
    // parseInt会自动去掉前导0，例如：12340 → "04321" → 4321
    let newHp = parseInt(reversedString, 10)

    // 上限80000
    if (newHp > 80000) {
      newHp = 80000
    }

    targetCity.currentHp = newHp

    gameStore.addLog(`${caster.name}对${targetPlayer.name}的${targetCity.name}使用了数位反转，HP从${Math.floor(currentHp)}变为${newHp}（每局限1次）`)

    return {
      success: true,
      message: `${targetCity.name}的HP已从${Math.floor(currentHp)}变为${newHp}`,
      data: {
        oldHp: currentHp,
        newHp: newHp
      }
    }
  }

  /**
   * 目不转睛 - 限制对手3回合内只能使用当机立断和无懈可击
   */
  function executeMuBuZhuanJing(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '目不转睛')) {
      gameStore.addLog(`${caster.name}使用目不转睛，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('目不转睛', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化目不转睛状态
    if (!gameStore.stareDown) {
      gameStore.stareDown = {}
    }

    gameStore.stareDown[target.name] = {
      roundsLeft: 3,
      source: caster.name
    }

    gameStore.addLog(`${caster.name}对${target.name}使用了目不转睛，${target.name}在接下来3回合内只能使用当机立断和无懈可击`)

    return {
      success: true,
      message: `${target.name}在接下来3回合内只能使用当机立断和无懈可击`
    }
  }

  /**
   * 过河拆桥 - 接下来使用的5个不同技能，其他玩家全部禁用
   */
  function executeGuoHeChaiQiao(caster) {
    // 检查是否已处于过河拆桥状态
    if (gameStore.burnBridge && gameStore.burnBridge[caster.name] && gameStore.burnBridge[caster.name].active) {
      return { success: false, message: '你已经处于过河拆桥状态！' }
    }

    // 检查对手是否有技能保护
    const mode = gameStore.gameMode || '2P'
    let opponents

    if (mode === '2v2') {
      const myTeam = caster.team
      opponents = gameStore.players.filter(p => p.team !== myTeam)
    } else {
      opponents = gameStore.players.filter(p => p.name !== caster.name)
    }

    for (const opp of opponents) {
      if (gameStore.skillProtection &&
          gameStore.skillProtection[opp.name] &&
          gameStore.skillProtection[opp.name].roundsLeft > 0) {
        return { success: false, message: `${opp.name}拥有技能保护，无法使用过河拆桥！` }
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('过河拆桥', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化过河拆桥状态
    if (!gameStore.burnBridge) {
      gameStore.burnBridge = {}
    }

    gameStore.burnBridge[caster.name] = {
      active: true,
      bannedSkills: []  // 记录已禁用的技能列表
    }

    gameStore.addLog(`${caster.name}使用了过河拆桥，接下来使用的5个不同技能将对其他玩家禁用`)

    return {
      success: true,
      message: '过河拆桥生效！接下来使用的5个不同技能将对其他玩家禁用'
    }
  }

  /**
   * 电磁感应 - 随机连接对手三座城市，3回合内连锁受伤
   */
  function executeDianCiGanYing(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '电磁感应')) {
      gameStore.addLog(`${caster.name}使用电磁感应，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('电磁感应', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取对手可连接的城市（排除钢铁城市和被保护城市）
    const eligibleCities = []
    target.cities.forEach((city, idx) => {
      if (!city || (city.currentHp || city.hp) <= 0 || city.isAlive === false) return

      // 检查是否为钢铁城市
      if (gameStore.ironCities && gameStore.ironCities[target.name] &&
          gameStore.ironCities[target.name].includes(idx)) {
        return
      }

      // 检查是否被保护
      if (gameStore.protections && gameStore.protections[target.name] &&
          gameStore.protections[target.name][idx] > 0) {
        return
      }

      eligibleCities.push(idx)
    })

    if (eligibleCities.length < 3) {
      return { success: false, message: `对手可连接的城市不足3个（当前${eligibleCities.length}个）` }
    }

    // 随机选择3个城市
    const shuffled = eligibleCities.sort(() => Math.random() - 0.5)
    const selectedCities = shuffled.slice(0, 3)

    // 初始化电磁感应状态
    if (!gameStore.electromagnetic) {
      gameStore.electromagnetic = {}
    }

    gameStore.electromagnetic[target.name] = {
      cities: selectedCities,
      roundsLeft: 3,
      source: caster.name
    }

    const cityNames = selectedCities.map(idx => target.cities[idx].name).join('、')
    gameStore.addLog(`${caster.name}对${target.name}使用了电磁感应，连接了${cityNames}，3回合内连锁受伤50%`)

    return {
      success: true,
      message: `成功连接${cityNames}，3回合内连锁受伤50%`,
      data: {
        connectedCities: selectedCities
      }
    }
  }

  /**
   * 厚积薄发 - 选定满血非中心城市，攻击力降为1，5回合后HP永久×5
   */
  function executeHouJiBaoFa(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const targetCityIdx = caster.cities.indexOf(selfCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '城市不存在' }
    }

    const mode = gameStore.gameMode || '2P'
    const is2p = (mode === '2P')
    const is2v2 = (mode === '2v2')
    const centerIdx = (is2p || is2v2) ? (caster.centerIndex ?? 0) : -1

    // 检查是否为中心城市
    if ((is2p || is2v2) && targetCityIdx === centerIdx) {
      return { success: false, message: '不能对中心城市使用厚积薄发！' }
    }

    // 检查城市是否满血
    const currentHp = selfCity.currentHp || selfCity.hp
    const initialHp = gameStore.initialCities &&
                      gameStore.initialCities[caster.name] &&
                      gameStore.initialCities[caster.name][targetCityIdx] ?
                      gameStore.initialCities[caster.name][targetCityIdx].hp :
                      selfCity.hp

    if (Math.abs(currentHp - initialHp) > 0.1) {
      return { success: false, message: '该城市当前HP不等于初始HP，无法使用厚积薄发！' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('厚积薄发', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化厚积薄发状态
    if (!gameStore.hjbf) {
      gameStore.hjbf = {}
    }
    if (!gameStore.hjbf[caster.name]) {
      gameStore.hjbf[caster.name] = {}
    }

    // 设置厚积薄发效果
    gameStore.hjbf[caster.name][targetCityIdx] = {
      roundsLeft: 5,
      originalHp: currentHp,
      active: true
    }

    gameStore.addLog(`${caster.name}对${selfCity.name}使用了厚积薄发，攻击力降为1，5回合后HP永久×5`)

    return {
      success: true,
      message: `${selfCity.name}进入厚积薄发状态，攻击力降为1，5回合后HP将永久×5`
    }
  }

  /**
   * 中庸之道 - 己方HP<10000的城市和对手HP>10000的城市，HP先开平方再×100
   */
  function executeZhongYongZhiDao(caster) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('中庸之道', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const mode = gameStore.gameMode || '2P'
    const affectedCities = []

    // 处理己方所有HP<10000的城市
    caster.cities.forEach((city, idx) => {
      if (city && (city.currentHp || city.hp) > 0 && (city.currentHp || city.hp) < 10000) {
        const oldHp = city.currentHp || city.hp
        const newHp = Math.floor(Math.sqrt(oldHp) * 100)
        city.currentHp = newHp

        affectedCities.push({
          player: caster.name,
          cityName: city.name,
          oldHp: Math.round(oldHp),
          newHp: newHp,
          type: '己方低HP'
        })
      }
    })

    // 处理全部对手所有HP>10000的城市
    gameStore.players.forEach(player => {
      if (player.name === caster.name) return

      // 在2v2模式下，跳过队友
      if (mode === '2v2' && player.team === caster.team) return

      // 检查坚不可摧护盾
      if (gameStore.isBlockedByJianbukecui(player.name, caster.name, '中庸之道')) {
        gameStore.addLog(`${caster.name}对${player.name}使用了中庸之道，但被坚不可摧护盾阻挡`)
        return
      }

      player.cities.forEach((city, idx) => {
        if (city && (city.currentHp || city.hp) > 0 && (city.currentHp || city.hp) > 10000) {
          // 检查海市蜃楼拦截（如果目标是中心城市）
          const is2pOr2v2 = (mode === '2P' || mode === '2v2')
          const centerIdx = is2pOr2v2 ? (player.centerIndex ?? 0) : -1
          const isCenter = is2pOr2v2 && idx === centerIdx

          if (isCenter && gameStore.mirage && gameStore.mirage[player.name] &&
              gameStore.mirage[player.name].roundsLeft > 0) {
            // 检查75%概率拦截
            if (Math.random() < 0.75) {
              gameStore.mirage[player.name].blocked++
              affectedCities.push({
                player: player.name,
                cityName: city.name,
                oldHp: Math.round(city.currentHp || city.hp),
                newHp: Math.round(city.currentHp || city.hp),
                type: '被海市蜃楼拦截'
              })
              return
            }
          }

          const oldHp = city.currentHp || city.hp
          const newHp = Math.floor(Math.sqrt(oldHp) * 100)
          city.currentHp = newHp

          affectedCities.push({
            player: player.name,
            cityName: city.name,
            oldHp: Math.round(oldHp),
            newHp: newHp,
            type: '对手高HP'
          })
        }
      })
    })

    const summary = affectedCities.map(c =>
      `${c.player}的${c.cityName}: ${c.oldHp}→${c.newHp}`
    ).join('；')

    gameStore.addLog(`${caster.name}使用了中庸之道，影响${affectedCities.length}座城市。${summary}`)

    return {
      success: true,
      message: `中庸之道生效！影响了${affectedCities.length}座城市`,
      data: {
        affectedCities: affectedCities
      }
    }
  }

  /**
   * 当机立断 - 立即停止对方所有持续技能效果
   */
  function executeDangJiLiDuan(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('当机立断', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const clearedEffects = []

    // 1. 清除对方对我方使用的天灾人祸
    if (gameStore.disasterDebuff && gameStore.disasterDebuff[caster.name]) {
      const disasterCount = Object.keys(gameStore.disasterDebuff[caster.name]).length
      if (disasterCount > 0) {
        delete gameStore.disasterDebuff[caster.name]
        clearedEffects.push(`天灾人祸×${disasterCount}`)
      }
    }

    // 2. 清除对方对我方使用的电磁感应
    if (gameStore.electromagnetic && gameStore.electromagnetic[caster.name] &&
        gameStore.electromagnetic[caster.name].source === target.name) {
      delete gameStore.electromagnetic[caster.name]
      clearedEffects.push('电磁感应')
    }

    // 3. 清除对方对我方使用的目不转睛
    if (gameStore.stareDown && gameStore.stareDown[caster.name] &&
        gameStore.stareDown[caster.name].source === target.name) {
      delete gameStore.stareDown[caster.name]
      clearedEffects.push('目不转睛')
    }

    // 4. 清除对方的定时爆破
    if (gameStore.timeBombs && gameStore.timeBombs[target.name]) {
      const bombCount = Object.keys(gameStore.timeBombs[target.name]).length
      if (bombCount > 0) {
        delete gameStore.timeBombs[target.name]
        clearedEffects.push(`定时爆破×${bombCount}`)
      }
    }

    // 5. 清除对方的不露踪迹
    if (gameStore.stealthMode && gameStore.stealthMode[target.name]) {
      delete gameStore.stealthMode[target.name]
      clearedEffects.push('不露踪迹')
    }

    // 6. 清除对方的屏障
    if (gameStore.barrier && gameStore.barrier[target.name]) {
      delete gameStore.barrier[target.name]
      clearedEffects.push('设置屏障')
    }

    // 7. 清除对方的潜能激发溢出
    if (gameStore.potentialOverflow && gameStore.potentialOverflow[target.name]) {
      delete gameStore.potentialOverflow[target.name]
      clearedEffects.push('潜能激发溢出')
    }

    if (clearedEffects.length === 0) {
      gameStore.addLog(`${caster.name}对${target.name}使用了当机立断，但没有可清除的效果`)
      return {
        success: true,
        message: '当机立断使用成功，但没有可清除的效果'
      }
    }

    const effectsStr = clearedEffects.join('、')
    gameStore.addLog(`${caster.name}对${target.name}使用了当机立断，清除了${effectsStr}`)

    return {
      success: true,
      message: `成功清除了${effectsStr}`,
      data: {
        clearedEffects: clearedEffects
      }
    }
  }

  /**
   * 言听计从 - 选定对手一座已知非中心城市，本回合该玩家必须向己方出战该城市
   */
  function executeYanTingJiCong(caster, target, targetCityIdx) {
    if (!target || targetCityIdx === undefined) {
      return { success: false, message: '未选择目标城市' }
    }

    const targetCity = target.cities[targetCityIdx]
    if (!targetCity || targetCity.currentHp <= 0 || targetCity.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查是否是中心城市
    const mode = gameStore.gameMode || '2P'
    if ((mode === '2P' || mode === '2v2') && target.centerIndex === targetCityIdx) {
      return { success: false, message: '无法指定对手中心城市' }
    }

    // 检查是否是以礼来降标记的城市
    if (gameStore.yillailiang &&
        gameStore.yillailiang[target.name] &&
        gameStore.yillailiang[target.name].cityIndex === targetCityIdx) {
      return { success: false, message: '无法选择以礼来降标记的城市' }
    }

    // 检查对手是否已经确认本回合的出战部署
    if (gameStore.deploymentConfirmed &&
        gameStore.deploymentConfirmed[target.name]) {
      return { success: false, message: '对手已经确认本回合出战，无法使用言听计从' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('言听计从', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 标记城市
    if (!gameStore.yantingjicong) {
      gameStore.yantingjicong = {}
    }
    gameStore.yantingjicong[target.name] = {
      cityIndex: targetCityIdx,
      demandBy: caster.name,
      enforced: false
    }

    gameStore.addLog(`${caster.name}对${target.name}使用了言听计从，要求本回合出战${targetCity.name}，否则将被抢夺`)

    return {
      success: true,
      message: `${target.name}必须本回合出战${targetCity.name}，否则将被抢夺`
    }
  }

  /**
   * 事半功倍 - 禁止所有对手使用选定技能（本局游戏），花费为目标技能一半向上取整
   */
  function executeShiBanGongBei(caster, skillName) {
    if (!skillName) {
      return { success: false, message: '未选择要禁用的技能' }
    }

    // 技能金币映射表（1-15金币技能）
    const SKILL_COST_MAP = {
      // 战斗金币技能
      '先声夺人': 1, '按兵不动': 2, '无知无畏': 2,
      '擒贼擒王': 3, '草木皆兵': 3, '越战越勇': 3,
      '吸引攻击': 4, '既来则安': 4,
      '铜墙铁壁': 5,
      '背水一战': 6, '料事如神': 6, '暗度陈仓': 6,
      '同归于尽': 7, '声东击西': 7, '欲擒故纵': 7,
      '御驾亲征': 8, '草船借箭': 8,
      '狂暴模式': 9, '以逸待劳': 9,
      '趁火打劫': 10, '晕头转向': 10, '隔岸观火': 10, '挑拨离间': 10,
      '反戈一击': 11,
      '围魏救赵': 13,
      '设置屏障': 15,
      // 非战斗金币技能
      '金币贷款': 1, '定海神针': 1, '城市侦探': 1,
      '焕然一新': 2, '改弦更张': 2, '抛砖引玉': 2,
      '城市保护': 3, '快速治疗': 3, '一举两得': 3, '明察秋毫': 3, '拔旗易帜': 3,
      '借尸还魂': 4, '高级治疗': 4, '进制扭曲': 4, '整齐划一': 4, '苟延残喘': 4,
      '众志成城': 5, '清除加成': 5, '钢铁城市': 5, '时来运转': 5, '实力增强': 5, '城市试炼': 5, '人质交换': 5, '釜底抽薪': 5, '避而不见': 5, '劫富济贫': 5, '一触即发': 5, '技能保护': 5, '无中生有': 5, '代行省权': 5,
      '李代桃僵': 6, '天灾人祸': 6, '博学多才': 6, '城市预言': 6, '守望相助': 6, '血量存储': 6, '海市蜃楼': 6,
      '提灯定损': 7, '好高骛远': 7, '目不转睛': 7, '连续打击': 7, '数位反转': 7, '倒反天罡': 7, '解除封锁': 7,
      '波涛汹涌': 8, '狂轰滥炸': 8, '横扫一空': 8, '万箭齐发': 8, '移花接木': 8, '连锁反应': 8, '招贤纳士': 8,
      '不露踪迹': 9, '降维打击': 9, '狐假虎威': 9, '过河拆桥': 9, '厚积薄发': 9,
      '深藏不露': 10, '定时爆破': 10,
      '永久摧毁': 11, '搬运救兵·普通': 11, '电磁感应': 11, '士气大振': 11, '战略转移': 11, '无懈可击': 11, '趁其不备·随机': 11,
      '自相残杀': 12, '当机立断': 12, '中庸之道': 12, '步步高升': 12,
      '搬运救兵·高级': 13, '强制迁都·普通': 13, '强制搬运': 13, '大义灭亲': 13,
      '趁其不备·指定': 14,
      '行政中心': 15
    }

    const originalCost = SKILL_COST_MAP[skillName]
    if (!originalCost || originalCost < 1 || originalCost > 15) {
      return { success: false, message: '该技能无法被禁用（不在1-15金币范围内）' }
    }

    const banCost = Math.ceil(originalCost / 2)

    // 金币检查
    if (caster.gold < banCost) {
      return { success: false, message: `金币不足！需要${banCost}金币，当前只有${caster.gold}金币` }
    }

    // 确定对手列表（2v2模式只禁用对方队伍，2P/3P禁用所有对手）
    const mode = gameStore.gameMode || '2P'
    let opponents
    if (mode === '2v2') {
      const myTeam = caster.team
      opponents = gameStore.players.filter(p => p.team !== myTeam)
    } else {
      opponents = gameStore.players.filter(p => p.name !== caster.name)
    }

    // 初始化 bannedSkills 结构
    if (!gameStore.bannedSkills) {
      gameStore.bannedSkills = {}
    }

    // 检查是否已被禁用
    let alreadyBanned = false
    for (const opp of opponents) {
      if (!gameStore.bannedSkills[opp.name]) {
        gameStore.bannedSkills[opp.name] = {}
      }
      if (gameStore.bannedSkills[opp.name][skillName]) {
        alreadyBanned = true
        break
      }
    }

    if (alreadyBanned) {
      return { success: false, message: `技能"${skillName}"已被禁用` }
    }

    // 检查对手是否有技能保护
    for (const opp of opponents) {
      if (gameStore.skillProtection &&
          gameStore.skillProtection[opp.name] &&
          gameStore.skillProtection[opp.name].roundsLeft > 0) {
        return { success: false, message: `${opp.name}拥有技能保护，无法对其使用事半功倍` }
      }
    }

    // 扣除金币
    caster.gold -= banCost

    // 禁用所有对手的该技能
    for (const opp of opponents) {
      if (!gameStore.bannedSkills[opp.name]) {
        gameStore.bannedSkills[opp.name] = {}
      }
      gameStore.bannedSkills[opp.name][skillName] = {
        bannedBy: caster.name,
        cost: banCost
      }
    }

    gameStore.addLog(`${caster.name}使用了事半功倍（花费${banCost}金币），禁用所有对手的"${skillName}"技能`)

    return {
      success: true,
      message: `成功禁用所有对手的"${skillName}"技能（花费${banCost}金币）`,
      data: {
        bannedSkill: skillName,
        cost: banCost,
        affectedPlayers: opponents.map(opp => opp.name)
      }
    }
  }

  /**
   * 倒反天罡 - 移除对手省会的归顺效果
   */
  function executeDaoFanTianGang(caster, target, capitalCityIdx) {
    if (!target || capitalCityIdx === undefined) {
      return { success: false, message: '未选择目标省会城市' }
    }

    const capital = target.cities[capitalCityIdx]
    if (!capital || capital.currentHp <= 0 || capital.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查是否是中心城市
    const mode = gameStore.gameMode || '2P'
    if ((mode === '2P' || mode === '2v2') && target.centerIndex === capitalCityIdx) {
      return { success: false, message: '无法对中心城市使用倒反天罡' }
    }

    // 检查是否是省会（需要省会判断逻辑）
    // 简化：假设城市有isCapitalCity属性或根据名称判断
    const isCapital = capital.isCapitalCity || gameStore.isCapitalCity(capital.name)
    if (!isCapital) {
      return { success: false, message: '目标城市不是省会城市' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '倒反天罡')) {
      gameStore.addLog(`${caster.name}使用倒反天罡，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('倒反天罡', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取省份名称
    const province = gameStore.getProvinceOfCity(capital.name)?.name || '未知省份'

    // 设置倒反天罡状态
    if (!gameStore.reversedCapitals) {
      gameStore.reversedCapitals = {}
    }
    if (!gameStore.reversedCapitals[target.name]) {
      gameStore.reversedCapitals[target.name] = {}
    }

    gameStore.reversedCapitals[target.name][capitalCityIdx] = {
      province: province,
      cityName: capital.name
    }

    gameStore.addLog(`${caster.name}对${target.name}的省会${capital.name}（${province}）使用了倒反天罡，该省会失去归顺效果`)

    return {
      success: true,
      message: `${capital.name}（${province}）失去归顺效果，该省不再触发省会归顺`,
      data: {
        capitalCity: capital.name,
        province: province
      }
    }
  }

  /**
   * 搬运救兵·普通 - 随机获得2个同省城市，强制3城出战
   */
  function executeBanyunJiubingPutong(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const myCityIdx = caster.cities.indexOf(selfCity)
    if (myCityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 获取有效省份（考虑拔旗易帜changeFlagMark）
    let provinceName
    if (gameStore.changeFlagMark &&
        gameStore.changeFlagMark[caster.name] &&
        gameStore.changeFlagMark[caster.name][myCityIdx]) {
      provinceName = gameStore.changeFlagMark[caster.name][myCityIdx].newProvince
    } else {
      const province = gameStore.getProvinceOfCity(selfCity.name)
      provinceName = province ? province.name : null
    }

    if (!provinceName || provinceName === '直辖市和特区') {
      return {
        success: false,
        message: '无法对直辖市和特别行政区的城市使用此技能！'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('搬运救兵·普通', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取所有已使用的城市名
    const usedNames = new Set()
    gameStore.players.forEach(player => {
      player.cities.forEach(city => {
        if (city && city.name) {
          usedNames.add(city.name)
        }
      })
    })

    // 从未使用城市池中筛选同省且可用的城市
    const unusedCities = gameStore.getUnusedCities()
    const availableCities = unusedCities.filter(c => {
      const cityProvince = gameStore.getProvinceOfCity(c.name)
      return cityProvince && cityProvince.name === provinceName && !usedNames.has(c.name)
    })

    if (availableCities.length < 2) {
      return {
        success: false,
        message: `${provinceName}中可用的未使用城市不足2个（当前${availableCities.length}个）`
      }
    }

    // 随机抽取2个
    const shuffled = [...availableCities].sort(() => Math.random() - 0.5)
    const picked = shuffled.slice(0, 2)

    const newCityIndices = []
    const addedCities = []

    for (const cityData of picked) {
      // 创建城市副本
      const newCity = {
        name: cityData.name,
        hp: cityData.hp,
        currentHp: cityData.hp,
        baseHp: cityData.hp,
        isAlive: true,
        red: cityData.red || 0,
        green: cityData.green || 0,
        blue: cityData.blue || 0,
        yellow: cityData.yellow || 0,
        modifiers: []
      }

      // 添加到玩家城市列表
      caster.cities.push(newCity)
      const newIdx = caster.cities.length - 1
      newCityIndices.push(newIdx)
      addedCities.push(newCity)

      // 标记为已使用
      gameStore.markCityAsUsed(cityData.name)

      // 记录到initialCities
      if (!gameStore.initialCities[caster.name]) {
        gameStore.initialCities[caster.name] = []
      }
      gameStore.initialCities[caster.name].push({ name: newCity.name, hp: newCity.hp })
    }

    // 强制这些城市本回合出战（原城市+2个新城市）
    if (!gameStore.playerStates[caster.name]) {
      gameStore.playerStates[caster.name] = {}
    }
    gameStore.playerStates[caster.name].forcedDeployment = {
      cities: [myCityIdx, ...newCityIndices],
      reason: '搬运救兵·普通'
    }

    gameStore.addLog(
      `${caster.name}使用搬运救兵·普通，从${provinceName}招募了${addedCities.map(c => `${c.name}(${c.hp})`).join('、')}，强制3城出战`
    )

    return {
      success: true,
      message: `招募了2个${provinceName}城市：${addedCities.map(c => c.name).join('、')}，强制3城出战`,
      data: {
        province: provinceName,
        addedCities: addedCities.map(c => ({ name: c.name, hp: c.hp }))
      }
    }
  }

  /**
   * 搬运救兵·高级 - 随机获得3个同省城市，含1个高HP城市
   */
  function executeBanyunJiubingGaoji(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const myCityIdx = caster.cities.indexOf(selfCity)
    if (myCityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    // 获取有效省份（考虑拔旗易帜）
    let provinceName
    if (gameStore.changeFlagMark &&
        gameStore.changeFlagMark[caster.name] &&
        gameStore.changeFlagMark[caster.name][myCityIdx]) {
      provinceName = gameStore.changeFlagMark[caster.name][myCityIdx].newProvince
    } else {
      const province = gameStore.getProvinceOfCity(selfCity.name)
      provinceName = province ? province.name : null
    }

    if (!provinceName || provinceName === '直辖市和特区') {
      return {
        success: false,
        message: '无法对直辖市和特别行政区的城市使用此技能！'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('搬运救兵·高级', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取所有已使用的城市名
    const usedNames = new Set()
    gameStore.players.forEach(player => {
      player.cities.forEach(city => {
        if (city && city.name) {
          usedNames.add(city.name)
        }
      })
    })

    // 从未使用城市池中筛选同省且可用的城市
    const unusedCities = gameStore.getUnusedCities()
    const availableCities = unusedCities.filter(c => {
      const cityProvince = gameStore.getProvinceOfCity(c.name)
      return cityProvince && cityProvince.name === provinceName && !usedNames.has(c.name)
    })

    if (availableCities.length < 3) {
      return {
        success: false,
        message: `${provinceName}中可用的未使用城市不足3个（当前${availableCities.length}个）`
      }
    }

    // 按HP排序（降序）
    const sorted = [...availableCities].sort((a, b) => b.hp - a.hp)

    // 选择高HP城市：如果目标城市是省内最高HP，则取第二高；否则取最高
    let highHpCity
    if (sorted.length === 1) {
      highHpCity = sorted[0]
    } else {
      const maxHp = sorted[0].hp
      if (selfCity.name === sorted[0].name) {
        highHpCity = sorted[1]
      } else {
        highHpCity = sorted[0]
      }
    }

    // 从可用城市中排除已选择的高HP城市，随机选择2个
    const remaining = availableCities.filter(c => c.name !== highHpCity.name)
    const shuffled = [...remaining].sort(() => Math.random() - 0.5)
    const randomTwo = shuffled.slice(0, 2)

    const picked = [highHpCity, ...randomTwo]
    const addedCities = []

    for (const cityData of picked) {
      // 创建城市副本
      const newCity = {
        name: cityData.name,
        hp: cityData.hp,
        currentHp: cityData.hp,
        baseHp: cityData.hp,
        isAlive: true,
        red: cityData.red || 0,
        green: cityData.green || 0,
        blue: cityData.blue || 0,
        yellow: cityData.yellow || 0,
        modifiers: []
      }

      // 添加到玩家城市列表
      caster.cities.push(newCity)
      addedCities.push(newCity)

      // 标记为已使用
      gameStore.markCityAsUsed(cityData.name)

      // 记录到initialCities
      if (!gameStore.initialCities[caster.name]) {
        gameStore.initialCities[caster.name] = []
      }
      gameStore.initialCities[caster.name].push({ name: newCity.name, hp: newCity.hp })
    }

    // 如果总城市数量 <= 5，自动加入预备
    const totalAliveCities = caster.cities.filter(c => c.isAlive !== false).length
    if (totalAliveCities <= 5) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      const startIdx = caster.cities.length - 3
      for (let i = startIdx; i < caster.cities.length; i++) {
        if (!gameStore.roster[caster.name].includes(i)) {
          gameStore.roster[caster.name].push(i)
        }
      }
    }

    // 检查战斗预备城市数量是否不足
    const mode = gameStore.gameMode || '2P'
    const requiredRosterSize = (mode === '2v2') ? 4 : 5
    const aliveRosterCities = (gameStore.roster[caster.name] || []).filter(idx => {
      const city = caster.cities[idx]
      return city && (city.currentHp || city.hp) > 0
    })

    if (aliveRosterCities.length < requiredRosterSize) {
      gameStore.addLog(`${caster.name}的战斗预备城市不足，请补充至${requiredRosterSize}个`)
    }

    gameStore.addLog(
      `${caster.name}使用搬运救兵·高级，从${provinceName}招募了${addedCities.map(c => `${c.name}(${c.hp})`).join('、')}`
    )

    return {
      success: true,
      message: `招募了3个${provinceName}城市：${addedCities.map(c => c.name).join('、')}`,
      data: {
        province: provinceName,
        addedCities: addedCities.map(c => ({ name: c.name, hp: c.hp })),
        highHpCity: highHpCity.name
      }
    }
  }

  /**
   * 趁其不备·随机 - 随机抢夺对手一座城市
   */
  function executeChenqibubeiSuiji(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '趁其不备·随机')) {
      gameStore.addLog(`${caster.name}使用趁其不备·随机，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('趁其不备·随机', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const mode = gameStore.gameMode || '2P'
    const centerIndex = (mode === '2P' || mode === '2v2') ? (target.centerIndex ?? 0) : -1
    const protections = (gameStore.protections && gameStore.protections[target.name]) || {}
    const ironCities = (gameStore.ironCities && gameStore.ironCities[target.name]) || {}
    const anchored = (gameStore.anchored && gameStore.anchored[target.name]) || {}
    const bbgs = (gameStore.bbgs && gameStore.bbgs[target.name]) || {}

    // 筛选可偷城市（排除中心城市、保护城市、钢铁城市、定海神针城市、步步高升城市）
    const eligible = target.cities
      .map((c, i) => ({ city: c, idx: i }))
      .filter(item => {
        if ((item.city.currentHp || item.city.hp) <= 0) return false
        if (item.city.isAlive === false) return false
        if (item.idx === centerIndex) return false // 排除中心城市
        if (protections[item.idx] && protections[item.idx] > 0) return false
        if (ironCities[item.idx]) return false
        if (anchored[item.idx] && anchored[item.idx] > 0) return false
        if (bbgs[item.idx]) return false
        return true
      })

    if (eligible.length === 0) {
      return {
        success: false,
        message: '对手没有可偷取的城市（排除中心、保护、钢铁、定海神针、步步高升城市）'
      }
    }

    // 随机选择一个
    const selected = eligible[Math.floor(Math.random() * eligible.length)]
    const stolenCity = { ...selected.city }
    const stolenCityName = stolenCity.name
    const stolenCityHp = stolenCity.currentHp || stolenCity.hp

    // 从对手移除城市
    target.cities.splice(selected.idx, 1)

    // 同步移除initialCities
    if (gameStore.initialCities[target.name]) {
      gameStore.initialCities[target.name].splice(selected.idx, 1)
    }

    // 更新对手的roster，修正索引
    if (gameStore.roster[target.name]) {
      gameStore.roster[target.name] = gameStore.roster[target.name]
        .filter(idx => idx !== selected.idx)
        .map(idx => idx > selected.idx ? idx - 1 : idx)
    }

    // 更新centerIndex
    if (target.centerIndex !== undefined && target.centerIndex > selected.idx) {
      target.centerIndex--
    }

    // 添加到己方
    caster.cities.push(stolenCity)
    const newIdx = caster.cities.length - 1

    // 记录到initialCities
    if (!gameStore.initialCities[caster.name]) {
      gameStore.initialCities[caster.name] = []
    }
    gameStore.initialCities[caster.name].push({ name: stolenCity.name, hp: stolenCity.baseHp || stolenCity.hp })

    // 如果总城市数量 <= 5，自动加入预备
    if (caster.cities.length <= 5) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      if (!gameStore.roster[caster.name].includes(newIdx)) {
        gameStore.roster[caster.name].push(newIdx)
      }
    }

    // 标记被偷走的城市为已知
    gameStore.setCityKnown(caster.name, newIdx, target.name)

    gameStore.addLog(
      `${caster.name}对${target.name}使用趁其不备·随机，抢夺了${stolenCityName}(HP:${Math.floor(stolenCityHp)})`
    )

    return {
      success: true,
      message: `成功抢夺了${stolenCityName}(HP:${Math.floor(stolenCityHp)})`,
      data: {
        stolenCity: stolenCityName,
        stolenHp: stolenCityHp
      }
    }
  }

  /**
   * 趁其不备·指定 - 指定抢夺对手一座已知城市
   */
  function executeChenqibubeiZhiding(caster, target, targetCity) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    const cityIdx = target.cities.indexOf(targetCity)
    if (cityIdx === -1) {
      return { success: false, message: '目标城市不存在' }
    }

    if ((targetCity.currentHp || targetCity.hp) <= 0 || targetCity.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
        !gameStore.knownCities[caster.name][target.name] ||
        !gameStore.knownCities[caster.name][target.name].includes(cityIdx)) {
      return { success: false, message: '该城市尚未已知，无法指定抢夺' }
    }

    // 检查是否是中心城市
    const mode = gameStore.gameMode || '2P'
    if ((mode === '2P' || mode === '2v2') && target.centerIndex === cityIdx) {
      return { success: false, message: '无法抢夺中心城市' }
    }

    // 检查城市保护
    if (gameStore.protections && gameStore.protections[target.name] &&
        gameStore.protections[target.name][cityIdx] &&
        gameStore.protections[target.name][cityIdx] > 0) {
      return { success: false, message: '该城市受保护，无法抢夺' }
    }

    // 检查钢铁城市
    if (gameStore.ironCities && gameStore.ironCities[target.name] &&
        gameStore.ironCities[target.name][cityIdx]) {
      return { success: false, message: '该城市是钢铁城市，无法抢夺' }
    }

    // 检查步步高升状态
    if (gameStore.bbgs &&
        gameStore.bbgs[target.name] &&
        gameStore.bbgs[target.name][cityIdx]) {
      return { success: false, message: '该城市有步步高升状态，无法抢夺' }
    }

    // 检查定海神针状态
    const anchored = (gameStore.anchored && gameStore.anchored[target.name]) || {}
    if (anchored[cityIdx] && anchored[cityIdx] > 0) {
      return { success: false, message: '该城市受定海神针保护，无法抢夺' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '趁其不备·指定')) {
      gameStore.addLog(`${caster.name}使用趁其不备·指定，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('趁其不备·指定', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const stolenCity = { ...targetCity }
    const stolenCityName = stolenCity.name
    const stolenCityHp = stolenCity.currentHp || stolenCity.hp

    // 从对手移除城市
    target.cities.splice(cityIdx, 1)

    // 同步移除initialCities
    if (gameStore.initialCities[target.name]) {
      gameStore.initialCities[target.name].splice(cityIdx, 1)
    }

    // 更新对手的roster，修正索引
    if (gameStore.roster[target.name]) {
      gameStore.roster[target.name] = gameStore.roster[target.name]
        .filter(idx => idx !== cityIdx)
        .map(idx => idx > cityIdx ? idx - 1 : idx)
    }

    // 更新centerIndex
    if (target.centerIndex !== undefined && target.centerIndex > cityIdx) {
      target.centerIndex--
    }

    // 添加到己方
    caster.cities.push(stolenCity)
    const newIdx = caster.cities.length - 1

    // 记录到initialCities
    if (!gameStore.initialCities[caster.name]) {
      gameStore.initialCities[caster.name] = []
    }
    gameStore.initialCities[caster.name].push({ name: stolenCity.name, hp: stolenCity.baseHp || stolenCity.hp })

    // 如果总城市数量 <= 5，自动加入预备
    if (caster.cities.length <= 5) {
      if (!gameStore.roster[caster.name]) {
        gameStore.roster[caster.name] = []
      }
      if (!gameStore.roster[caster.name].includes(newIdx)) {
        gameStore.roster[caster.name].push(newIdx)
      }
    }

    // 标记被偷走的城市为已知
    gameStore.setCityKnown(caster.name, newIdx, target.name)

    gameStore.addLog(
      `${caster.name}对${target.name}使用趁其不备·指定，抢夺了${stolenCityName}(HP:${Math.floor(stolenCityHp)})`
    )

    return {
      success: true,
      message: `成功抢夺了${stolenCityName}(HP:${Math.floor(stolenCityHp)})`,
      data: {
        stolenCity: stolenCityName,
        stolenHp: stolenCityHp
      }
    }
  }

  /**
   * 拔旗易帜 - 交换己方和对手各一个非省会城市的省份归属
   */
  function executeBaQiYiZhi(caster, target, params) {
    const { myCityIdx, oppCityIdx } = params

    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (myCityIdx === undefined || oppCityIdx === undefined) {
      return { success: false, message: '未选择城市' }
    }

    // 辅助函数：获取城市的有效省份（考虑拔旗易帜）
    const getEffectiveProvince = (player, cityIdx) => {
      if (gameStore.changeFlagMark &&
          gameStore.changeFlagMark[player.name] &&
          gameStore.changeFlagMark[player.name][cityIdx]) {
        return gameStore.changeFlagMark[player.name][cityIdx].newProvince
      }
      const city = player.cities[cityIdx]
      return city ? (city.province || gameStore.getProvinceName(city.name)) : null
    }

    const myCity = caster.cities[myCityIdx]
    const oppCity = target.cities[oppCityIdx]

    if (!myCity || !oppCity) {
      return { success: false, message: '城市不存在' }
    }

    if (myCity.currentHp <= 0 || myCity.isAlive === false) {
      return { success: false, message: '己方城市已阵亡' }
    }

    if (oppCity.currentHp <= 0 || oppCity.isAlive === false) {
      return { success: false, message: '对方城市已阵亡' }
    }

    const myProv = getEffectiveProvince(caster, myCityIdx)
    const oppProv = getEffectiveProvince(target, oppCityIdx)

    if (!myProv || !oppProv) {
      return { success: false, message: '无法获取城市省份信息' }
    }

    // 检查是否是省会
    if (gameStore.isCapitalCity(myCity.name, myProv)) {
      return { success: false, message: '己方城市是省会，无法使用拔旗易帜' }
    }

    if (gameStore.isCapitalCity(oppCity.name, oppProv)) {
      return { success: false, message: '对方城市是省会，无法使用拔旗易帜' }
    }

    // 检查是否是直辖市和特区
    if (myProv === '直辖市和特区') {
      return { success: false, message: '己方城市属于直辖市和特区，无法使用拔旗易帜' }
    }

    if (oppProv === '直辖市和特区') {
      return { success: false, message: '对方城市属于直辖市和特区，无法使用拔旗易帜' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('拔旗易帜', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化changeFlagMark结构
    if (!gameStore.changeFlagMark) {
      gameStore.changeFlagMark = {}
    }
    if (!gameStore.changeFlagMark[caster.name]) {
      gameStore.changeFlagMark[caster.name] = {}
    }
    if (!gameStore.changeFlagMark[target.name]) {
      gameStore.changeFlagMark[target.name] = {}
    }

    // 交换省份归属
    gameStore.changeFlagMark[caster.name][myCityIdx] = {
      newProvince: oppProv,
      originalProvince: myProv
    }

    gameStore.changeFlagMark[target.name][oppCityIdx] = {
      newProvince: myProv,
      originalProvince: oppProv
    }

    gameStore.addLog(
      `${caster.name}对${target.name}使用了拔旗易帜，交换了${myCity.name}（${myProv}→${oppProv}）和${oppCity.name}（${oppProv}→${myProv}）的省份归属`
    )

    return {
      success: true,
      message: `成功交换省份归属：${myCity.name}（${myProv}→${oppProv}）和${oppCity.name}（${oppProv}→${myProv}）`,
      data: {
        myCityName: myCity.name,
        oppCityName: oppCity.name,
        myProvChange: { from: myProv, to: oppProv },
        oppProvChange: { from: oppProv, to: myProv }
      }
    }
  }

  /**
   * 守望相助 - 指定己方一个非直辖市城市，当该城市死亡时自动复活同省一个已死城市
   */
  function executeShouWangXiangZhu(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '该城市已阵亡' }
    }

    const prov = selfCity.province || gameStore.getProvinceName(selfCity.name)

    // 检查是否是直辖市/特别行政区
    if (prov === '北京市' || prov === '上海市' || prov === '天津市' || prov === '重庆市' ||
        prov === '香港特别行政区' || prov === '澳门特别行政区' || prov === '直辖市和特区') {
      return {
        success: false,
        message: '无法对直辖市和特别行政区的城市使用守望相助'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('守望相助', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化mutualWatch结构
    if (!gameStore.mutualWatch) {
      gameStore.mutualWatch = {}
    }
    if (!gameStore.mutualWatch[caster.name]) {
      gameStore.mutualWatch[caster.name] = {}
    }

    // 设置守望相助状态
    gameStore.mutualWatch[caster.name][cityIdx] = {
      province: prov,
      cityName: selfCity.name
    }

    gameStore.addLog(
      `${caster.name}对${selfCity.name}（${prov}）使用了守望相助，当该城市阵亡时将自动复活同省一个已死城市`
    )

    return {
      success: true,
      message: `${selfCity.name}获得守望相助效果，阵亡时将自动复活同省一个已死城市`,
      data: {
        cityName: selfCity.name,
        province: prov
      }
    }
  }

  /**
   * 以礼来降 - 标记对手一座已知非中心城市
   */
  function executeYiLiLaiJiang(caster, target, targetCity) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    const targetCityIdx = target.cities.indexOf(targetCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '目标城市不存在' }
    }

    if (targetCity.currentHp <= 0 || targetCity.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查是否是中心城市
    const mode = gameStore.gameMode || '2P'
    if ((mode === '2P' || mode === '2v2') && target.centerIndex === targetCityIdx) {
      return { success: false, message: '无法对中心城市使用以礼来降' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
        !gameStore.knownCities[caster.name][target.name] ||
        !gameStore.knownCities[caster.name][target.name].includes(targetCityIdx)) {
      return { success: false, message: '该城市尚未已知，无法使用以礼来降' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('以礼来降', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化yillailiang结构
    if (!gameStore.yillailiang) {
      gameStore.yillailiang = {}
    }

    // 设置以礼来降标记
    gameStore.yillailiang[target.name] = {
      cityIndex: targetCityIdx,
      markedBy: caster.name,
      cityName: targetCity.name
    }

    // 撤除钢铁城市状态
    if (gameStore.ironCities && gameStore.ironCities[target.name] &&
        gameStore.ironCities[target.name][targetCityIdx]) {
      delete gameStore.ironCities[target.name][targetCityIdx]
      gameStore.addLog(`${targetCity.name}的钢铁城市状态被撤除`)
    }

    // 撤除保护罩
    if (gameStore.protections && gameStore.protections[target.name] &&
        gameStore.protections[target.name][targetCityIdx]) {
      delete gameStore.protections[target.name][targetCityIdx]
      gameStore.addLog(`${targetCity.name}的保护罩被撤除`)
    }

    // 加入谨慎交换集合
    if (!gameStore.cautiousSet) {
      gameStore.cautiousSet = {}
    }
    if (!gameStore.cautiousSet[target.name]) {
      gameStore.cautiousSet[target.name] = []
    }
    if (!gameStore.cautiousSet[target.name].includes(targetCityIdx)) {
      gameStore.cautiousSet[target.name].push(targetCityIdx)
    }

    gameStore.addLog(
      `${caster.name}对${target.name}的${targetCity.name}使用了以礼来降，该城市被标记并加入谨慎交换集合`
    )

    return {
      success: true,
      message: `成功标记${targetCity.name}，当该城市被消灭后将获得该城市并随机抢夺对方一座城市`,
      data: {
        targetCity: targetCity.name,
        targetPlayer: target.name
      }
    }
  }

  /**
   * 大义灭亲 - 选择己方一个非直辖市城市，摧毁同省所有对手城市（非省会）
   */
  function executeDaYiMieQin(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const myCityIdx = caster.cities.indexOf(selfCity)
    if (myCityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '己方城市已阵亡' }
    }

    // 获取有效省份（考虑拔旗易帜）
    let myProv
    if (gameStore.changeFlagMark &&
        gameStore.changeFlagMark[caster.name] &&
        gameStore.changeFlagMark[caster.name][myCityIdx]) {
      myProv = gameStore.changeFlagMark[caster.name][myCityIdx].newProvince
    } else {
      myProv = selfCity.province || gameStore.getProvinceName(selfCity.name)
    }

    // 检查是否是直辖市/特别行政区
    if (myProv === '北京市' || myProv === '上海市' || myProv === '天津市' || myProv === '重庆市' ||
        myProv === '香港特别行政区' || myProv === '澳门特别行政区' || myProv === '直辖市和特区') {
      return {
        success: false,
        message: '无法对直辖市和特别行政区的城市使用大义灭亲'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('大义灭亲', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const mode = gameStore.gameMode || '2P'
    let destroyLog = []
    let protectLog = []
    let totalDestroyed = 0

    // 遍历所有对手玩家
    gameStore.players.forEach(opp => {
      if (opp.name === caster.name) return

      // 在2v2模式下，跳过队友
      if (mode === '2v2' && opp.team === caster.team) return

      // 检查坚不可摧护盾
      if (gameStore.isBlockedByJianbukecui(opp.name, caster.name, '大义灭亲')) {
        gameStore.addLog(`${caster.name}对${opp.name}使用了大义灭亲，但被坚不可摧护盾阻挡`)
        return // 跳过该对手
      }

      const citiesToRemove = []

      opp.cities.forEach((oppCity, idx) => {
        if (!oppCity || oppCity.currentHp <= 0 || oppCity.isAlive === false) return

        // 获取有效省份（考虑拔旗易帜）
        let oppProv
        if (gameStore.changeFlagMark &&
            gameStore.changeFlagMark[opp.name] &&
            gameStore.changeFlagMark[opp.name][idx]) {
          oppProv = gameStore.changeFlagMark[opp.name][idx].newProvince
        } else {
          oppProv = oppCity.province || gameStore.getProvinceName(oppCity.name)
        }

        // 同省且非直辖市/特区
        if (oppProv === myProv) {
          // 检查是否是直辖市或特区城市
          const province = gameStore.getProvinceOfCity(oppCity.name)
          const provinceName = province ? province.name : null
          if (provinceName === '直辖市和特区') {
            return // 跳过直辖市和特区城市
          }

          // 检查是否是中心城市（2P/2v2模式）
          if ((mode === '2P' || mode === '2v2') && idx === (opp.centerIndex ?? 0)) {
            return // 跳过中心城市
          }

          // 检查保护和铁城
          let hasProtection = false

          // 检查保护罩
          if (gameStore.protections && gameStore.protections[opp.name] &&
              gameStore.protections[opp.name][idx] && gameStore.protections[opp.name][idx] > 0) {
            gameStore.protections[opp.name][idx] -= 1
            protectLog.push(`${opp.name}的${oppCity.name}保护层数-1（剩余${gameStore.protections[opp.name][idx]}）`)
            hasProtection = true
          }
          // 检查铁城
          else if (gameStore.ironCities && gameStore.ironCities[opp.name] &&
                   gameStore.ironCities[opp.name][idx]) {
            delete gameStore.ironCities[opp.name][idx]
            protectLog.push(`${opp.name}的${oppCity.name}铁城状态被移除`)
            hasProtection = true
          }

          // 如果没有保护，则摧毁
          if (!hasProtection) {
            citiesToRemove.push({ idx, name: oppCity.name })
          }
        }
      })

      // 从后往前删除城市
      for (let i = citiesToRemove.length - 1; i >= 0; i--) {
        const { idx, name } = citiesToRemove[i]
        opp.cities.splice(idx, 1)
        destroyLog.push(`${opp.name}的${name}`)
        totalDestroyed++

        // 清理相关状态
        if (gameStore.mutualWatch && gameStore.mutualWatch[opp.name]) {
          delete gameStore.mutualWatch[opp.name][idx]
        }
        if (gameStore.changeFlagMark && gameStore.changeFlagMark[opp.name]) {
          delete gameStore.changeFlagMark[opp.name][idx]
        }

        // 调整 centerIndex
        if (opp.centerIndex !== undefined && idx < opp.centerIndex) {
          opp.centerIndex--
        }

        // 调整 roster
        if (gameStore.roster && gameStore.roster[opp.name]) {
          gameStore.roster[opp.name] = gameStore.roster[opp.name]
            .filter(rIdx => rIdx !== idx)
            .map(rIdx => rIdx > idx ? rIdx - 1 : rIdx)
        }
      }
    })

    // 日志记录
    if (protectLog.length > 0) {
      protectLog.forEach(log => gameStore.addLog(log))
    }

    if (destroyLog.length > 0) {
      gameStore.addLog(
        `${caster.name}使用了大义灭亲（${myProv}），摧毁了：${destroyLog.join('、')}`
      )
    } else {
      gameStore.addLog(
        `${caster.name}使用了大义灭亲（${myProv}），但没有摧毁任何城市`
      )
    }

    return {
      success: true,
      message: `摧毁了${totalDestroyed}个同省对手城市`,
      data: {
        province: myProv,
        destroyed: destroyLog,
        protected: protectLog
      }
    }
  }

  /**
   * 强制迁都·普通 - 选定一个对手，直接淘汰对方中心城市，对方自己选定新的中心城市
   */
  function executeQiangZhiQianDuPutong(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    const mode = gameStore.gameMode || '2P'
    if (mode !== '2P' && mode !== '2v2') {
      return {
        success: false,
        message: '该技能仅限2P/2v2模式使用！'
      }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '强制迁都·普通')) {
      gameStore.addLog(`${caster.name}使用强制迁都·普通，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('强制迁都·普通', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const centerIdx = target.centerIndex ?? 0
    const centerCity = target.cities[centerIdx]

    if (!centerCity) {
      return { success: false, message: '对方没有中心城市' }
    }

    // 淘汰中心城市
    centerCity.isAlive = false
    centerCity.currentHp = 0

    // 添加到deadCities列表
    if (!gameStore.deadCities[target.name]) {
      gameStore.deadCities[target.name] = []
    }
    if (!gameStore.deadCities[target.name].includes(centerIdx)) {
      gameStore.deadCities[target.name].push(centerIdx)
    }

    // 设置需要选择新中心的标记
    if (!gameStore.playerStates[target.name]) {
      gameStore.playerStates[target.name] = {}
    }
    gameStore.playerStates[target.name].needsNewCenter = true
    gameStore.playerStates[target.name].newCenterReason = '强制迁都·普通'

    gameStore.addLog(
      `${caster.name}对${target.name}使用了强制迁都·普通，${centerCity.name}被淘汰，${target.name}需要选择新的中心城市`
    )

    return {
      success: true,
      message: `成功淘汰${target.name}的中心城市${centerCity.name}，对方需要选择新的中心城市`,
      data: {
        destroyedCenter: centerCity.name,
        targetPlayer: target.name
      }
    }
  }

  /**
   * 强制迁都·高级版 - 选择对手的一个已知城市作为新中心，旧中心直接阵亡
   */
  function executeQiangZhiQianDuGaoji(caster, target, newCenterCity) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (!newCenterCity) {
      return { success: false, message: '未选择新中心城市' }
    }

    const mode = gameStore.gameMode || '2P'
    if (mode !== '2P' && mode !== '2v2') {
      return {
        success: false,
        message: '该技能仅限2P/2v2模式使用！'
      }
    }

    const newCenterIdx = target.cities.indexOf(newCenterCity)
    if (newCenterIdx === -1) {
      return { success: false, message: '目标城市不存在' }
    }

    if (newCenterCity.currentHp <= 0 || newCenterCity.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
        !gameStore.knownCities[caster.name][target.name] ||
        !gameStore.knownCities[caster.name][target.name].includes(newCenterIdx)) {
      return { success: false, message: '该城市尚未已知，无法指定为新中心' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '强制迁都·高级版')) {
      gameStore.addLog(`${caster.name}使用强制迁都·高级版，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('强制迁都·高级版', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const oldCenterIdx = target.centerIndex ?? 0
    const oldCenterCity = target.cities[oldCenterIdx]

    // 淘汰旧中心城市
    if (oldCenterCity) {
      oldCenterCity.isAlive = false
      oldCenterCity.currentHp = 0
      oldCenterCity.isCenter = false

      // 添加到deadCities列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (!gameStore.deadCities[target.name].includes(oldCenterIdx)) {
        gameStore.deadCities[target.name].push(oldCenterIdx)
      }
    }

    // 设置新中心城市
    newCenterCity.isCenter = true
    target.centerIndex = newCenterIdx

    gameStore.addLog(
      `${caster.name}对${target.name}使用了强制迁都·高级，${oldCenterCity?.name}被淘汰，${newCenterCity.name}成为新的中心城市`
    )

    return {
      success: true,
      message: `成功将${newCenterCity.name}设为${target.name}的新中心城市，旧中心${oldCenterCity?.name}已阵亡`,
      data: {
        oldCenter: oldCenterCity?.name,
        newCenter: newCenterCity.name,
        targetPlayer: target.name
      }
    }
  }

  /**
   * 夷为平地 - 直接摧毁对方钢铁城市；若为中心城市则强制迁都；若为副中心则撤销并HP变20%
   */
  function executeYiWeiPingDi(caster, target, targetCity) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    const targetCityIdx = target.cities.indexOf(targetCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '目标城市不存在' }
    }

    if (targetCity.currentHp <= 0 || targetCity.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '夷为平地')) {
      gameStore.addLog(`${caster.name}使用夷为平地，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('夷为平地', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const mode = gameStore.gameMode || '2P'
    const isCenterCity = (mode === '2P' || mode === '2v2') && targetCityIdx === (target.centerIndex ?? 0)

    // 检查是否为钢铁城市
    const isIronCity = gameStore.ironCities &&
                       gameStore.ironCities[target.name] &&
                       gameStore.ironCities[target.name][targetCityIdx]

    if (isIronCity) {
      // 摧毁钢铁城市
      delete gameStore.ironCities[target.name][targetCityIdx]

      if (isCenterCity) {
        // 中心城市：强制迁都
        targetCity.isAlive = false
        targetCity.currentHp = 0
        targetCity.isCenter = false

        // 添加到deadCities列表
        if (!gameStore.deadCities[target.name]) {
          gameStore.deadCities[target.name] = []
        }
        if (!gameStore.deadCities[target.name].includes(targetCityIdx)) {
          gameStore.deadCities[target.name].push(targetCityIdx)
        }

        // 设置需要选择新中心的标记
        if (!gameStore.playerStates[target.name]) {
          gameStore.playerStates[target.name] = {}
        }
        gameStore.playerStates[target.name].needsNewCenter = true
        gameStore.playerStates[target.name].newCenterReason = '夷为平地'

        gameStore.addLog(
          `${caster.name}对${target.name}使用了夷为平地，摧毁了钢铁中心城市${targetCity.name}，${target.name}需要选择新的中心城市`
        )

        return {
          success: true,
          message: `成功摧毁钢铁中心城市${targetCity.name}，对方需要选择新的中心城市`,
          data: {
            destroyedCity: targetCity.name,
            wasCenter: true
          }
        }
      } else {
        // 检查是否为副中心
        const isViceCenter = gameStore.viceCenters &&
                            gameStore.viceCenters[target.name] &&
                            gameStore.viceCenters[target.name].includes(targetCityIdx)

        if (isViceCenter) {
          // 副中心：撤销副中心资格并HP变20%
          gameStore.viceCenters[target.name] = gameStore.viceCenters[target.name]
            .filter(idx => idx !== targetCityIdx)

          const currentHp = targetCity.currentHp || targetCity.hp
          targetCity.currentHp = Math.floor(currentHp * 0.2)

          gameStore.addLog(
            `${caster.name}对${target.name}使用了夷为平地，摧毁了钢铁副中心${targetCity.name}，HP降至${Math.floor(targetCity.currentHp)}`
          )

          return {
            success: true,
            message: `成功撤销${targetCity.name}的副中心资格并将其HP降至20%`,
            data: {
              cityName: targetCity.name,
              wasViceCenter: true,
              newHp: targetCity.currentHp
            }
          }
        } else {
          // 普通钢铁城市：直接摧毁
          targetCity.isAlive = false
          targetCity.currentHp = 0

          // 添加到deadCities列表
          if (!gameStore.deadCities[target.name]) {
            gameStore.deadCities[target.name] = []
          }
          if (!gameStore.deadCities[target.name].includes(targetCityIdx)) {
            gameStore.deadCities[target.name].push(targetCityIdx)
          }

          gameStore.addLog(
            `${caster.name}对${target.name}使用了夷为平地，摧毁了钢铁城市${targetCity.name}`
          )

          return {
            success: true,
            message: `成功摧毁钢铁城市${targetCity.name}`,
            data: {
              destroyedCity: targetCity.name,
              wasIronCity: true
            }
          }
        }
      }
    } else {
      return {
        success: false,
        message: `${targetCity.name}不是钢铁城市，无法使用夷为平地`
      }
    }
  }

  /**
   * 行政中心 - 将己方所有直辖市、特别行政区、省会、首府、计划单列市HP×3
   */
  function executeXingZhengZhongXin(caster) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('行政中心', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const adminCitiesToBoost = []

    caster.cities.forEach((city, idx) => {
      if (!city || city.currentHp <= 0 || city.isAlive === false) return

      // 检查是否为直辖市、特别行政区、省会、首府、计划单列市
      const isSpecialCity = gameStore.isCapitalCity(city.name) ||
                           gameStore.isPlanCity(city.name) ||
                           gameStore.isMunicipality(city.name) ||
                           gameStore.isSpecialAdministrativeRegion(city.name)

      if (isSpecialCity) {
        const beforeHp = city.hp
        city.hp = city.hp * 3

        // 应用HP上限
        const currentHp = city.currentHp || city.hp
        if (currentHp > city.hp) {
          city.currentHp = city.hp
        }

        // 同步更新initialCities中的HP
        if (gameStore.initialCities[caster.name] &&
            gameStore.initialCities[caster.name][idx]) {
          gameStore.initialCities[caster.name][idx].hp = city.hp
        }

        adminCitiesToBoost.push({
          name: city.name,
          before: Math.floor(beforeHp),
          after: Math.floor(city.hp)
        })
      }
    })

    if (adminCitiesToBoost.length === 0) {
      gameStore.addLog(`${caster.name}使用了行政中心，但没有符合条件的城市`)
      return {
        success: true,
        message: '没有符合条件的城市（需要直辖市、特别行政区、省会、首府或计划单列市）'
      }
    }

    const summary = adminCitiesToBoost.map(c =>
      `${c.name}(${c.before}→${c.after})`
    ).join('、')

    gameStore.addLog(`${caster.name}使用了行政中心，提升了${adminCitiesToBoost.length}座城市：${summary}`)

    return {
      success: true,
      message: `成功提升${adminCitiesToBoost.length}座特殊城市的HP（×3）`,
      data: {
        boosted: adminCitiesToBoost
      }
    }
  }

  /**
   * 代行省权 - 临时指定己方一个非省会城市为省会
   */
  function executeDaiXingShengQuan(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '该城市已阵亡' }
    }

    // 获取城市省份
    const prov = selfCity.province || gameStore.getProvinceName(selfCity.name)

    if (!prov) {
      return { success: false, message: '无法确定城市所属省份' }
    }

    // 检查是否已经是省会
    const isCapital = selfCity.isCapitalCity || gameStore.isCapitalCity(selfCity.name, prov)

    if (isCapital) {
      return { success: false, message: '该城市已经是省会城市，无需代行省权' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('代行省权', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化actingCapital结构
    if (!gameStore.actingCapital) {
      gameStore.actingCapital = {}
    }
    if (!gameStore.actingCapital[caster.name]) {
      gameStore.actingCapital[caster.name] = {}
    }

    // 设置临时省会状态
    gameStore.actingCapital[caster.name][cityIdx] = {
      province: prov,
      cityName: selfCity.name
    }

    gameStore.addLog(`${caster.name}对${selfCity.name}使用了代行省权，该城市临时成为${prov}的省会`)

    return {
      success: true,
      message: `${selfCity.name}临时成为${prov}的省会`,
      data: {
        cityName: selfCity.name,
        province: prov
      }
    }
  }

  /**
   * 副中心制 - 设置一座城市为副中心，攻击力×1.5，自动成为永久钢铁城市
   */
  function executeFuZhongXinZhi(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '该城市已阵亡' }
    }

    // 检查是否已经是副中心
    if (gameStore.subCenters &&
        gameStore.subCenters[caster.name] === cityIdx) {
      return {
        success: false,
        message: '该城市已经是副中心城市'
      }
    }

    // 检查是否已有其他副中心
    if (gameStore.subCenters &&
        gameStore.subCenters[caster.name] !== undefined) {
      const oldIdx = gameStore.subCenters[caster.name]
      const oldCity = caster.cities[oldIdx]
      return {
        success: false,
        message: `${oldCity?.name}已经是副中心，一个玩家只能有一个副中心城市`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('副中心制', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 初始化subCenters结构
    if (!gameStore.subCenters) {
      gameStore.subCenters = {}
    }

    // 设置副中心
    gameStore.subCenters[caster.name] = cityIdx

    // 自动设为永久钢铁城市（2层）
    if (!gameStore.ironCities) {
      gameStore.ironCities = {}
    }
    if (!gameStore.ironCities[caster.name]) {
      gameStore.ironCities[caster.name] = {}
    }
    gameStore.ironCities[caster.name][cityIdx] = 2  // ✅ 修复：设置为2层，而非true

    gameStore.addLog(`${caster.name}对${selfCity.name}使用了副中心制，该城市成为副中心并获得钢铁城市状态（2层），攻击力×1.5`)

    return {
      success: true,
      message: `${selfCity.name}成为副中心，攻击力×1.5，并自动成为钢铁城市（2层免疫）`,
      data: {
        cityName: selfCity.name,
        cityIdx: cityIdx
      }
    }
  }

  /**
   * 计划单列 - 随机从厦门、大连、青岛、宁波、深圳的HP中抽取，提升战斗预备城市HP并恢复蓝色技能
   */
  function executeJiHuaDanLie(caster) {
    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('计划单列', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 定义计划单列市池（按原版权重）
    const pool = [
      { name: '厦门', hp: 8589, weight: 33 },
      { name: '大连', hp: 9517, weight: 30 },
      { name: '青岛', hp: 16719, weight: 20 },
      { name: '宁波', hp: 18148, weight: 15 },
      { name: '深圳', hp: 36802, weight: 2 }
    ]

    // 加权随机选择
    const sumWeight = pool.reduce((s, x) => s + x.weight, 0)
    let r = Math.random() * sumWeight
    let pick = pool[0]

    for (const item of pool) {
      if (r < item.weight) {
        pick = item
        break
      }
      r -= item.weight
    }

    // 获取战斗预备城市索引
    const rosterIndices = gameStore.roster[caster.name] || []

    if (rosterIndices.length === 0) {
      return {
        success: false,
        message: '没有战斗预备城市可以提升'
      }
    }

    let hpChanged = 0
    let blueRestored = 0
    const affectedCities = []

    // 对战斗预备城市进行处理
    rosterIndices.forEach(ci => {
      const city = caster.cities[ci]
      if (!city || city.currentHp <= 0 || city.isAlive === false) return

      let cityChanged = false
      const beforeHp = city.hp

      // 提升HP到抽到城市的HP
      if (city.hp < pick.hp) {
        city.hp = pick.hp

        // 应用HP上限
        const currentHp = city.currentHp || city.hp
        if (currentHp > city.hp) {
          city.currentHp = city.hp
        }

        // 同步更新initialCities
        if (gameStore.initialCities[caster.name] &&
            gameStore.initialCities[caster.name][ci]) {
          gameStore.initialCities[caster.name][ci].hp = city.hp
        }

        hpChanged++
        cityChanged = true
      }

      // 恢复蓝色技能到初始状态
      const initialCityData = gameStore.initialCities &&
                              gameStore.initialCities[caster.name] &&
                              gameStore.initialCities[caster.name][ci]

      if (initialCityData && initialCityData.blue !== undefined &&
          city.blue !== initialCityData.blue) {
        city.blue = initialCityData.blue
        blueRestored++
        cityChanged = true
      }

      if (cityChanged) {
        affectedCities.push({
          name: city.name,
          beforeHp: Math.floor(beforeHp),
          afterHp: Math.floor(city.hp)
        })
      }
    })

    const summary = affectedCities.map(c =>
      `${c.name}(${c.beforeHp}→${c.afterHp})`
    ).join('、')

    gameStore.addLog(
      `${caster.name}使用了计划单列，抽到${pick.name}(${pick.hp})，提升了${hpChanged}个城市HP，恢复了${blueRestored}个城市的蓝色技能。${summary}`
    )

    return {
      success: true,
      message: `抽到${pick.name}(${pick.hp})，提升${hpChanged}个城市HP，恢复${blueRestored}个蓝色技能`,
      data: {
        selectedCity: pick.name,
        selectedHp: pick.hp,
        hpChanged: hpChanged,
        blueRestored: blueRestored,
        affected: affectedCities
      }
    }
  }

  /**
   * 步步高升 - 给予城市特殊状态，免疫特定技能，阵亡后可召唤同省更高HP城市（最多3次）
   */
  function executeBuBuGaoSheng(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '该城市已阵亡' }
    }

    const mode = gameStore.gameMode || '2P'
    const is2pOr2v2 = (mode === '2P' || mode === '2v2')

    // 检查是否为中心城市
    if (is2pOr2v2 && cityIdx === (caster.centerIndex ?? 0)) {
      return { success: false, message: '不能对中心城市使用步步高升' }
    }

    // 获取城市省份（考虑拔旗易帜）
    let prov
    if (gameStore.changeFlagMark &&
        gameStore.changeFlagMark[caster.name] &&
        gameStore.changeFlagMark[caster.name][cityIdx]) {
      prov = gameStore.changeFlagMark[caster.name][cityIdx].newProvince
    } else {
      prov = selfCity.province || gameStore.getProvinceName(selfCity.name)
    }

    // 检查是否为直辖市/特别行政区
    if (prov === '直辖市和特区' ||
        prov === '北京市' || prov === '上海市' || prov === '天津市' || prov === '重庆市' ||
        prov === '香港特别行政区' || prov === '澳门特别行政区') {
      return {
        success: false,
        message: '不能对直辖市和特别行政区的城市使用步步高升'
      }
    }

    // 检查是否已有步步高升状态
    if (gameStore.bbgs &&
        gameStore.bbgs[caster.name] &&
        gameStore.bbgs[caster.name][cityIdx]) {
      return {
        success: false,
        message: '该城市已有步步高升状态'
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('步步高升', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取城市的原始HP（从城市池中查找）
    const originalCityData = gameStore.getCityByName(selfCity.name)
    const originalHp = originalCityData ? originalCityData.hp : (selfCity.baseHp || selfCity.hp)

    // 初始化bbgs结构
    if (!gameStore.bbgs) {
      gameStore.bbgs = {}
    }
    if (!gameStore.bbgs[caster.name]) {
      gameStore.bbgs[caster.name] = {}
    }

    // 设置步步高升状态
    gameStore.bbgs[caster.name][cityIdx] = {
      count: 0,
      maxCount: 3,
      originalHp: originalHp
    }

    // 加入谨慎交换集合
    if (!gameStore.cautiousSet) {
      gameStore.cautiousSet = {}
    }
    if (!gameStore.cautiousSet[caster.name]) {
      gameStore.cautiousSet[caster.name] = []
    }
    if (!gameStore.cautiousSet[caster.name].includes(cityIdx)) {
      gameStore.cautiousSet[caster.name].push(cityIdx)
    }

    gameStore.addLog(
      `${caster.name}对${selfCity.name}使用了步步高升，该城市免疫特定技能，阵亡后可召唤同省更高HP城市（最多3次）`
    )

    return {
      success: true,
      message: `${selfCity.name}获得步步高升状态，免疫四面楚歌、趁其不备等技能，阵亡后可复活3次`,
      data: {
        cityName: selfCity.name,
        province: prov,
        originalHp: originalHp
      }
    }
  }

  /**
   * 生于紫室 - 给予城市2倍攻击力，成为未知城市，中心阵亡时自动继任，每回合+10%HP
   */
  function executeShengYuZiShi(caster, selfCity) {
    if (!selfCity) {
      return { success: false, message: '未选择城市' }
    }

    const cityIdx = caster.cities.indexOf(selfCity)
    if (cityIdx === -1) {
      return { success: false, message: '城市不在玩家城市列表中' }
    }

    if (selfCity.currentHp <= 0 || selfCity.isAlive === false) {
      return { success: false, message: '该城市已阵亡' }
    }

    const mode = gameStore.gameMode || '2P'
    const is2pOr2v2 = (mode === '2P' || mode === '2v2')
    const centerIndex = is2pOr2v2 ? (caster.centerIndex ?? 0) : -1

    // 不能对中心城市使用
    if (is2pOr2v2 && cityIdx === centerIndex) {
      return { success: false, message: '不能对中心城市使用生于紫室' }
    }

    // 初始化purpleChamber结构
    if (!gameStore.purpleChamber) {
      gameStore.purpleChamber = {}
    }

    const oldChamberIdx = gameStore.purpleChamber[caster.name]
    const hasOldChamber = oldChamberIdx !== undefined

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('生于紫室', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    if (hasOldChamber) {
      // 已有加成城市，执行转移逻辑
      const oldCity = caster.cities[oldChamberIdx]
      const newCity = selfCity
      const centerCity = caster.cities[centerIndex]

      const oldCityHp = oldCity ? (oldCity.currentHp || oldCity.hp) : 0
      const newCityHp = newCity.currentHp || newCity.hp
      const centerHp = centerCity ? (centerCity.currentHp || centerCity.hp) : 0

      // 转移判定：中心>旧城市>新城市
      if (centerHp > oldCityHp && oldCityHp > newCityHp) {
        // 条件满足，执行转移
        gameStore.purpleChamber[caster.name] = cityIdx

        // 清除旧城市的未知状态
        if (gameStore.knownCities) {
          for (const oppName in gameStore.knownCities) {
            if (gameStore.knownCities[oppName][caster.name]) {
              if (!gameStore.knownCities[oppName][caster.name].includes(oldChamberIdx)) {
                gameStore.knownCities[oppName][caster.name].push(oldChamberIdx)
              }
            }
          }
        }

        // 设置新城市为未知
        gameStore.clearCityKnownStatus(caster.name, cityIdx)

        gameStore.addLog(
          `${caster.name}将生于紫室加成从${oldCity?.name}转移到${newCity.name}（转移条件：中心${Math.floor(centerHp)}>旧${Math.floor(oldCityHp)}>新${Math.floor(newCityHp)}）`
        )

        return {
          success: true,
          message: `成功将生于紫室加成从${oldCity?.name}转移到${newCity.name}`,
          data: {
            transferred: true,
            oldCity: oldCity?.name,
            newCity: newCity.name
          }
        }
      } else {
        // 条件不满足
        return {
          success: false,
          message: `转移条件不满足：需要中心HP(${Math.floor(centerHp)})>旧城市HP(${Math.floor(oldCityHp)})>新城市HP(${Math.floor(newCityHp)})`
        }
      }
    } else {
      // 首次使用，直接赋予加成
      gameStore.purpleChamber[caster.name] = cityIdx

      // 设置为未知城市
      gameStore.clearCityKnownStatus(caster.name, cityIdx)

      gameStore.addLog(
        `${caster.name}对${selfCity.name}使用了生于紫室，该城市获得2倍攻击力，成为未知城市，每回合HP+10%，中心阵亡时自动继任`
      )

      return {
        success: true,
        message: `${selfCity.name}获得生于紫室加成：2倍攻击力，成为未知城市，每回合HP+10%，中心阵亡时自动继任`,
        data: {
          transferred: false,
          cityName: selfCity.name,
          cityIdx: cityIdx
        }
      }
    }
  }

  /**
   * 强制搬运 - 对手已知城市使用搬运救兵·普通，并强制下回合出战这三座城市
   */
  function executeQiangZhiBanYun(caster, target, targetCity) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (!targetCity) {
      return { success: false, message: '未选择目标城市' }
    }

    const targetCityIdx = target.cities.indexOf(targetCity)
    if (targetCityIdx === -1) {
      return { success: false, message: '目标城市不存在' }
    }

    if (targetCity.currentHp <= 0 || targetCity.isAlive === false) {
      return { success: false, message: '目标城市已阵亡' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
        !gameStore.knownCities[caster.name][target.name] ||
        !gameStore.knownCities[caster.name][target.name].includes(targetCityIdx)) {
      return { success: false, message: '该城市尚未已知，无法使用强制搬运' }
    }

    // 获取有效省份（考虑拔旗易帜）
    let provinceName
    if (gameStore.changeFlagMark &&
        gameStore.changeFlagMark[target.name] &&
        gameStore.changeFlagMark[target.name][targetCityIdx]) {
      provinceName = gameStore.changeFlagMark[target.name][targetCityIdx].newProvince
    } else {
      provinceName = targetCity.province || gameStore.getProvinceName(targetCity.name)
    }

    if (!provinceName) {
      return { success: false, message: `未找到${targetCity.name}所属省份` }
    }

    if (provinceName === '直辖市和特区' || provinceName === '北京市' || provinceName === '上海市' ||
        provinceName === '天津市' || provinceName === '重庆市' || provinceName === '香港特别行政区' ||
        provinceName === '澳门特别行政区') {
      return {
        success: false,
        message: '不能对直辖市和特区的城市使用强制搬运'
      }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '强制搬运')) {
      gameStore.addLog(`${caster.name}使用强制搬运，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('强制搬运', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 获取所有已使用的城市名
    const usedNames = new Set()
    gameStore.players.forEach(player => {
      player.cities.forEach(city => {
        if (city && city.name) {
          usedNames.add(city.name)
        }
      })
    })

    // 从未使用城市池中筛选同省且可用的城市
    const unusedCities = gameStore.getUnusedCities()
    const availableCities = unusedCities.filter(c => {
      const cityProvince = gameStore.getProvinceOfCity(c.name)
      return cityProvince && cityProvince.name === provinceName && !usedNames.has(c.name)
    })

    if (availableCities.length < 2) {
      return {
        success: false,
        message: `${provinceName}可用城市不足（需要2个，剩余${availableCities.length}个）`
      }
    }

    // 随机抽取2个城市
    const shuffled = [...availableCities].sort(() => Math.random() - 0.5)
    const picked = shuffled.slice(0, 2)

    // 添加城市到对手
    const newCityIndices = []
    const pickedNames = []

    picked.forEach(cityData => {
      const newCity = {
        name: cityData.name,
        hp: cityData.hp,
        currentHp: cityData.hp,
        baseHp: cityData.hp,
        isAlive: true,
        red: cityData.red || 0,
        green: cityData.green || 0,
        blue: cityData.blue || 0,
        yellow: cityData.yellow || 0,
        modifiers: []
      }

      target.cities.push(newCity)
      newCityIndices.push(target.cities.length - 1)
      pickedNames.push(newCity.name)

      // 标记为已使用
      gameStore.markCityAsUsed(cityData.name)
    })

    // 记录到initialCities
    if (!gameStore.initialCities[target.name]) {
      gameStore.initialCities[target.name] = []
    }
    picked.forEach(cityData => {
      gameStore.initialCities[target.name].push({ name: cityData.name, hp: cityData.hp })
    })

    // 设置强制出战标记
    if (!gameStore.playerStates[target.name]) {
      gameStore.playerStates[target.name] = {}
    }
    gameStore.playerStates[target.name].forcedDeployment = {
      cities: [targetCityIdx, ...newCityIndices], // 原城市 + 2个新城市
      reason: '强制搬运'
    }

    // 禁用对方部分技能3回合
    if (!gameStore.forcedSoldierBan) {
      gameStore.forcedSoldierBan = {}
    }
    gameStore.forcedSoldierBan[target.name] = {
      roundsLeft: 3,
      bannedSkills: ['改弦更张', '搬运救兵·普通', '搬运救兵·高级']
    }

    gameStore.addLog(
      `${caster.name}对${target.name}使用了强制搬运，为其招募了${pickedNames.join('、')}，强制下回合出战${targetCity.name}和新城市`
    )

    return {
      success: true,
      message: `成功为${target.name}招募2个${provinceName}城市：${pickedNames.join('、')}，并强制下回合出战`,
      data: {
        province: provinceName,
        originalCity: targetCity.name,
        newCities: pickedNames
      }
    }
  }

  /**
   * 自相残杀 - 对手两座城市互相攻击
   */
  function executeZiXiangCanSha(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '自相残杀')) {
      gameStore.addLog(`${caster.name}使用自相残杀，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('自相残杀', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    const myRoster = gameStore.roster[target.name] || []

    // 获取非战斗预备城市（排除钢铁城市和被保护城市）
    const nonRosterCities = []
    target.cities.forEach((city, idx) => {
      if (!city || (city.currentHp || city.hp) <= 0 || city.isAlive === false) return
      if (myRoster.includes(idx)) return

      // 检查钢铁城市
      if (gameStore.ironCities && gameStore.ironCities[target.name] &&
          gameStore.ironCities[target.name].includes(idx)) {
        return
      }

      // 检查保护
      if (gameStore.protections && gameStore.protections[target.name] &&
          gameStore.protections[target.name][idx] > 0) {
        return
      }

      nonRosterCities.push(idx)
    })

    // 获取战斗预备城市（排除钢铁城市和被保护城市）
    const rosterCities = myRoster.filter(idx => {
      const city = target.cities[idx]
      if (!city || (city.currentHp || city.hp) <= 0 || city.isAlive === false) return false

      // 检查钢铁城市
      if (gameStore.ironCities && gameStore.ironCities[target.name] &&
          gameStore.ironCities[target.name].includes(idx)) {
        return false
      }

      // 检查保护
      if (gameStore.protections && gameStore.protections[target.name] &&
          gameStore.protections[target.name][idx] > 0) {
        return false
      }

      return true
    })

    if (nonRosterCities.length === 0 || rosterCities.length === 0) {
      return {
        success: false,
        message: `可用的非战斗预备城市或战斗预备城市不足`
      }
    }

    // 随机选择
    const nonRosterIdx = nonRosterCities[Math.floor(Math.random() * nonRosterCities.length)]
    const rosterIdx = rosterCities[Math.floor(Math.random() * rosterCities.length)]

    const nonRosterCity = target.cities[nonRosterIdx]
    const rosterCity = target.cities[rosterIdx]

    const nonRosterHp = nonRosterCity.currentHp || nonRosterCity.hp
    const rosterHp = rosterCity.currentHp || rosterCity.hp

    // 互相攻击：HP低的阵亡，HP高的扣除阵亡城市的HP
    if (nonRosterHp < rosterHp) {
      // 非预备城市阵亡
      nonRosterCity.isAlive = false
      nonRosterCity.currentHp = 0

      // 战斗预备城市扣除HP
      rosterCity.currentHp = rosterHp - nonRosterHp

      // 添加到阵亡列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (!gameStore.deadCities[target.name].includes(nonRosterIdx)) {
        gameStore.deadCities[target.name].push(nonRosterIdx)
      }

      gameStore.addLog(`${caster.name}对${target.name}使用了自相残杀，${nonRosterCity.name}（${Math.floor(nonRosterHp)}）与${rosterCity.name}（${Math.floor(rosterHp)}）互相攻击，${nonRosterCity.name}阵亡，${rosterCity.name}剩余${Math.floor(rosterCity.currentHp)}HP`)
    } else if (nonRosterHp > rosterHp) {
      // 战斗预备城市阵亡
      rosterCity.isAlive = false
      rosterCity.currentHp = 0

      // 非预备城市扣除HP
      nonRosterCity.currentHp = nonRosterHp - rosterHp

      // 从战斗预备中移除
      const rosterIndex = myRoster.indexOf(rosterIdx)
      if (rosterIndex !== -1) {
        myRoster.splice(rosterIndex, 1)
      }

      // 添加到阵亡列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (!gameStore.deadCities[target.name].includes(rosterIdx)) {
        gameStore.deadCities[target.name].push(rosterIdx)
      }

      // 强制非预备城市进入战斗预备
      if (!myRoster.includes(nonRosterIdx)) {
        myRoster.push(nonRosterIdx)
      }

      gameStore.addLog(`${caster.name}对${target.name}使用了自相残杀，${nonRosterCity.name}（${Math.floor(nonRosterHp)}）与${rosterCity.name}（${Math.floor(rosterHp)}）互相攻击，${rosterCity.name}阵亡，${nonRosterCity.name}剩余${Math.floor(nonRosterCity.currentHp)}HP并强制进入战斗预备`)
    } else {
      // HP相等，同归于尽
      nonRosterCity.isAlive = false
      nonRosterCity.currentHp = 0
      rosterCity.isAlive = false
      rosterCity.currentHp = 0

      // 从战斗预备中移除
      const rosterIndex = myRoster.indexOf(rosterIdx)
      if (rosterIndex !== -1) {
        myRoster.splice(rosterIndex, 1)
      }

      // 添加到阵亡列表
      if (!gameStore.deadCities[target.name]) {
        gameStore.deadCities[target.name] = []
      }
      if (!gameStore.deadCities[target.name].includes(nonRosterIdx)) {
        gameStore.deadCities[target.name].push(nonRosterIdx)
      }
      if (!gameStore.deadCities[target.name].includes(rosterIdx)) {
        gameStore.deadCities[target.name].push(rosterIdx)
      }

      gameStore.addLog(`${caster.name}对${target.name}使用了自相残杀，${nonRosterCity.name}与${rosterCity.name}HP相等（${Math.floor(nonRosterHp)}），同归于尽`)
    }

    return {
      success: true,
      message: `自相残杀生效！${nonRosterCity.name}与${rosterCity.name}互相攻击`
    }
  }

  /**
   * 城市侦探 - 查看对手一座已知城市的详细信息
   */
  function executeCityDetective(caster, target, targetCityIdx) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    if (targetCityIdx === undefined) {
      return { success: false, message: '未选择目标城市' }
    }

    const targetCity = target.cities[targetCityIdx]
    if (!targetCity) {
      return { success: false, message: '目标城市不存在' }
    }

    // 检查城市是否已知
    if (!gameStore.knownCities || !gameStore.knownCities[caster.name] ||
        !gameStore.knownCities[caster.name][target.name] ||
        !gameStore.knownCities[caster.name][target.name].includes(targetCityIdx)) {
      return { success: false, message: '该城市尚未已知，无法使用城市侦探' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('城市侦探', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '城市侦探')) {
      gameStore.addLog(`${caster.name}使用城市侦探，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 创建快照（用于无懈可击拦截）
    gameStore.createGameStateSnapshot()

    // 获取初始HP
    const initialCityData = gameStore.initialCities &&
                            gameStore.initialCities[target.name] &&
                            gameStore.initialCities[target.name][targetCityIdx]
    const originalHp = initialCityData ? initialCityData.hp : (targetCity.baseHp || targetCity.hp)

    const currentHp = targetCity.currentHp || targetCity.hp

    // 构建城市信息
    const cityInfo = {
      name: targetCity.name,
      originalHp: Math.floor(originalHp),
      currentHp: Math.floor(currentHp),
      red: targetCity.red || 0,
      green: targetCity.green || 0,
      blue: targetCity.blue || 0,
      yellow: targetCity.yellow || 0
    }

    const infoText = `城市名：${cityInfo.name}\nHP原始值：${cityInfo.originalHp}\n当前HP：${cityInfo.currentHp}\n红色技能：Lv${cityInfo.red}\n绿色技能：Lv${cityInfo.green}\n蓝色技能：Lv${cityInfo.blue}\n黄色技能：Lv${cityInfo.yellow}`

    // 记录私有日志（只有施法者能看到）
    if (gameStore.addPrivateLog) {
      gameStore.addPrivateLog(caster.name, `你对${target.name}使用了城市侦探，查看了${cityInfo.name}的信息：\n${infoText}`)
    }

    // 记录公开日志
    gameStore.addLog(`${caster.name}对${target.name}使用了城市侦探`)

    // 记录技能使用追踪（用于冷却和次数限制）
    gameStore.recordSkillUsageTracking(caster.name, '城市侦探')

    // 记录技能使用（用于无懈可击拦截）
    gameStore.lastSkillUsed = {
      userName: caster.name,
      skillName: '城市侦探',
      cost: 1,
      roundNumber: gameStore.currentRound,
      timestamp: Date.now()
    }

    return {
      success: true,
      message: `城市侦探：\n\n${infoText}`,
      data: {
        cityInfo: cityInfo
      }
    }
  }

  /**
   * 城市预言 - 查看对手所有战斗预备城市的详细信息
   */
  function executeChengShiYuYan(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('城市预言', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '城市预言')) {
      gameStore.addLog(`${caster.name}使用城市预言，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 创建快照（用于无懈可击拦截）
    gameStore.createGameStateSnapshot()

    // 获取对手的战斗预备城市列表（roster）
    const rosterIndices = gameStore.roster[target.name] || []

    if (rosterIndices.length === 0) {
      // 返还金币
      caster.gold += 6
      return {
        success: false,
        message: `${target.name}没有战斗预备城市！金币已返还`
      }
    }

    // 收集所有预备城市的详细信息
    const cityInfoList = []
    rosterIndices.forEach(cityIdx => {
      const city = target.cities[cityIdx]
      if (!city) return

      // 获取初始HP
      const initialCityData = gameStore.initialCities &&
                              gameStore.initialCities[target.name] &&
                              gameStore.initialCities[target.name][cityIdx]
      const originalHp = initialCityData ? initialCityData.hp : (city.baseHp || city.hp)

      const colors = []
      if (city.red > 0) colors.push(`红${city.red}`)
      if (city.green > 0) colors.push(`绿${city.green}`)
      if (city.blue > 0) colors.push(`蓝${city.blue}`)
      if (city.yellow > 0) colors.push(`黄${city.yellow}`)

      cityInfoList.push({
        name: city.name,
        originalHp: Math.floor(originalHp),
        currentHp: Math.floor(city.currentHp || city.hp),
        colors: colors.length > 0 ? colors.join('、') : '无'
      })

      // 标记为已知（但生于紫室城市除外）
      if (!(gameStore.purpleChamber && gameStore.purpleChamber[target.name] === cityIdx)) {
        gameStore.setCityKnown(target.name, cityIdx, caster.name)
      }
    })

    // 记录私有日志
    if (gameStore.addPrivateLog) {
      const infoText = cityInfoList.map((info, index) =>
        `${index + 1}. ${info.name} - 原始HP:${info.originalHp} 当前HP:${info.currentHp} 技能:${info.colors}`
      ).join('\n')
      gameStore.addPrivateLog(caster.name, `你对${target.name}使用了城市预言，查看了其${rosterIndices.length}座战斗预备城市的详细信息：\n${infoText}`)
    }

    // 记录公开日志
    gameStore.addLog(`${caster.name}对${target.name}使用了城市预言`)

    // 记录技能使用追踪（用于次数限制）
    gameStore.recordSkillUsageTracking(caster.name, '城市预言')

    return {
      success: true,
      message: `成功查看${target.name}的${cityInfoList.length}座战斗预备城市`,
      data: {
        cityInfoList: cityInfoList
      }
    }
  }

  /**
   * 一举两得 - 强制对手本回合必须派出2个城市，无法使用按兵不动
   */
  function executeYiJuLiangDe(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查对手存活城市数
    const oppAliveCities = target.cities.filter(c => c && (c.currentHp || c.hp) > 0)
    if (oppAliveCities.length < 2) {
      return {
        success: false,
        message: `${target.name}存活城市不足2个，无法使用一举两得`
      }
    }

    // 检查双方卡牌数量都≥3
    const myAliveCities = caster.cities.filter(c => c && (c.currentHp || c.hp) > 0)
    if (myAliveCities.length < 3 || oppAliveCities.length < 3) {
      return {
        success: false,
        message: `一举两得需要双方卡牌数量都≥3！当前你有${myAliveCities.length}个，对方有${oppAliveCities.length}个`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('一举两得', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '一举两得')) {
      gameStore.addLog(`${caster.name}使用一举两得，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 创建快照（用于无懈可击拦截）
    gameStore.createGameStateSnapshot()

    // 设置强制出战2个城市的标记（仅本回合有效）
    if (!gameStore.forceDeployTwo) {
      gameStore.forceDeployTwo = {}
    }
    gameStore.forceDeployTwo[target.name] = {
      active: true,
      round: gameStore.currentRound
    }

    // 一举两得禁用按兵不动（仅本回合有效）
    if (!gameStore.cannotStandDown) {
      gameStore.cannotStandDown = {}
    }
    gameStore.cannotStandDown[target.name] = {
      active: true,
      round: gameStore.currentRound
    }

    // 记录私有日志
    if (gameStore.addPrivateLog) {
      gameStore.addPrivateLog(caster.name, `你对${target.name}使用了一举两得，对方本回合必须派出2个城市，无法使用按兵不动`)
    }

    // 记录公开日志
    gameStore.addLog(`${caster.name}对${target.name}使用了一举两得`)

    // 记录技能使用（用于无懈可击拦截）
    gameStore.lastSkillUsed = {
      userName: caster.name,
      skillName: '一举两得',
      cost: 3,
      roundNumber: gameStore.currentRound,
      timestamp: Date.now()
    }

    return {
      success: true,
      message: `成功使用一举两得！${target.name}本回合必须派出2个城市`
    }
  }

  /**
   * 明察秋毫 - 查看对手本回合的出战部署
   */
  function executeMingChaQiuHao(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('明察秋毫', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '明察秋毫')) {
      gameStore.addLog(`${caster.name}使用明察秋毫，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 创建快照（用于无懈可击拦截）
    gameStore.createGameStateSnapshot()

    // 获取对手的当前部署
    const oppState = gameStore.playerStates[target.name]
    if (!oppState || !oppState.currentBattleCities || oppState.currentBattleCities.length === 0) {
      // 对方未部署，返还金币
      caster.gold += 3
      return {
        success: false,
        message: `${target.name}还未部署城市！金币已返还`
      }
    }

    // 构建部署信息
    const deploymentInfo = []
    oppState.currentBattleCities.forEach(card => {
      const city = target.cities[card.cityIdx]
      if (!city) return

      const colors = []
      if (card.red > 0) colors.push(`红${card.red}`)
      if (card.green > 0) colors.push(`绿${card.green}`)
      if (card.blue > 0) colors.push(`蓝${card.blue}`)
      if (card.yellow > 0) colors.push(`黄${card.yellow}`)
      const colorStr = colors.length > 0 ? `（${colors.join('、')}）` : ''

      deploymentInfo.push({
        name: city.name,
        hp: Math.floor(city.currentHp || city.hp),
        colors: colorStr
      })

      // 标记为已知城市
      gameStore.setCityKnown(target.name, card.cityIdx, caster.name)
    })

    const infoText = deploymentInfo.map(info =>
      `${info.name}（HP:${info.hp}）${info.colors}`
    ).join('\n')

    // 记录私有日志
    if (gameStore.addPrivateLog) {
      gameStore.addPrivateLog(caster.name, `你对${target.name}使用了明察秋毫，查看到对方部署：\n${infoText}`)
    }

    // 记录公开日志
    gameStore.addLog(`${caster.name}对${target.name}使用了明察秋毫`)

    // 记录技能使用追踪（用于冷却和次数限制）
    gameStore.recordSkillUsageTracking(caster.name, '明察秋毫')

    return {
      success: true,
      message: `明察秋毫：\n\n${target.name}的部署：\n${infoText}`,
      data: {
        deploymentInfo: deploymentInfo
      }
    }
  }

  /**
   * 四面楚歌 - 归顺同省非特殊城市，特殊城市HP减半
   * 对手所有与己方存活城市同省的非中心城市归顺
   * 省会/首府/计划单列市/直辖市/特区HP减半
   *
   * @param {Object} caster - 施法者
   * @param {Object} target - 目标对手
   * @returns {Object} { success, message, data }
   */
  function executeSiMianChuGe(caster, target) {
    if (!target) {
      return { success: false, message: '未选择对手' }
    }

    // 检查坚不可摧护盾
    if (gameStore.isBlockedByJianbukecui(target.name, caster.name, '四面楚歌')) {
      gameStore.addLog(`${caster.name}使用四面楚歌，但被${target.name}的坚不可摧护盾阻挡`)
      return {
        success: false,
        message: `被${target.name}的坚不可摧护盾阻挡`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('四面楚歌', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 创建快照
    gameStore.createGameStateSnapshot()

    // 省会城市列表
    const CAPITAL_CITIES = [
      '石家庄', '太原', '呼和浩特', '沈阳', '长春', '哈尔滨',
      '南京', '杭州', '合肥', '福州', '南昌', '济南', '郑州',
      '武汉', '长沙', '广州', '南宁', '海口', '成都', '贵阳',
      '昆明', '拉萨', '西安', '兰州', '西宁', '银川', '乌鲁木齐'
    ]

    // 计划单列市
    const PLAN_CITIES = ['大连', '青岛', '深圳', '厦门', '宁波']

    // 直辖市
    const MUNICIPALITIES = ['北京', '上海', '天津', '重庆']

    // 获取有效城市名称（考虑狐假虎威伪装）
    const getEffectiveName = (playerName, cityIdx) => {
      const disguise = gameStore.disguisedCities &&
                      gameStore.disguisedCities[playerName] &&
                      gameStore.disguisedCities[playerName][cityIdx]
      if (disguise && disguise.roundsLeft > 0) {
        return disguise.disguiseAsName || gameStore.players.find(p => p.name === playerName).cities[cityIdx].name
      }
      const player = gameStore.players.find(p => p.name === playerName)
      return player.cities[cityIdx].name
    }

    // 判断是否为特殊城市
    const isCapitalCity = (cityName) => {
      const cleanName = cityName.replace(/(市|县|区)$/g, '')
      return CAPITAL_CITIES.some(cap => cleanName.includes(cap) || cap.includes(cleanName))
    }

    const isPlanCity = (cityName) => {
      const cleanName = cityName.replace(/(市|县|区)$/g, '')
      return PLAN_CITIES.some(plan => cleanName.includes(plan) || plan.includes(cleanName))
    }

    const isMunicipality = (cityName) => {
      const cleanName = cityName.replace(/(市|县|区)$/g, '')
      return MUNICIPALITIES.some(mun => cleanName.includes(mun) || mun.includes(cleanName))
    }

    const isSpecialAdministrativeRegion = (cityName) => {
      return cityName.includes('香港') || cityName.includes('澳门')
    }

    // 获取城市所属省份（考虑拔旗易帜）
    const getCityProvince = (playerName, cityIdx, cityName) => {
      // 检查拔旗易帜标记
      if (gameStore.changeFlagMark &&
          gameStore.changeFlagMark[playerName] &&
          gameStore.changeFlagMark[playerName][cityIdx]) {
        return gameStore.changeFlagMark[playerName][cityIdx].newProvince
      }

      // 直辖市和特区使用城市名本身作为省份
      if (isMunicipality(cityName) || isSpecialAdministrativeRegion(cityName)) {
        const cleanName = cityName.replace(/(市|县|区)$/g, '')
        if (MUNICIPALITIES.includes(cleanName)) {
          return cleanName + '市'
        }
        if (cityName.includes('香港')) return '香港特别行政区'
        if (cityName.includes('澳门')) return '澳门特别行政区'
      }

      // 使用gameStore的省份映射（假设已存在）
      if (gameStore.getProvinceName) {
        return gameStore.getProvinceName(cityName)
      }

      // 简化处理：返回null表示无法确定省份
      return null
    }

    // 获取己方所有存活城市的省份集合
    const myProvinces = new Set()
    caster.cities.forEach((city, ci) => {
      if (city && (city.currentHp || city.hp) > 0) {
        const effectiveName = getEffectiveName(caster.name, ci)
        const prov = getCityProvince(caster.name, ci, effectiveName)
        if (prov) {
          myProvinces.add(prov)
        }
      }
    })

    if (myProvinces.size === 0) {
      // 返还金币
      caster.gold += 23
      gameStore.addLog(`${caster.name}使用四面楚歌，但没有可用的省份！金币已返还`)
      return {
        success: false,
        message: '你没有可用的城市！金币已返还'
      }
    }

    // 确定是否有中心城市概念（仅2P和2v2）
    const gameMode = gameStore.gameMode || '2P'
    const hasCenterCity = (gameMode === '2P' || gameMode === '2v2')
    const oppCenterIndex = hasCenterCity ? (target.centerIndex ?? 0) : -1

    const transferredCities = []
    const halvedCities = []
    const exposedFoxCities = []

    // 第一阶段：对手所有非中心的特殊城市HP全部减半
    for (let ci = 0; ci < target.cities.length; ci++) {
      const city = target.cities[ci]
      if (!city || (city.currentHp || city.hp) <= 0) continue
      if (hasCenterCity && ci === oppCenterIndex) continue

      const effectiveName = getEffectiveName(target.name, ci)
      const isSpecial = isCapitalCity(effectiveName) ||
                       isPlanCity(effectiveName) ||
                       isMunicipality(effectiveName) ||
                       isSpecialAdministrativeRegion(effectiveName)

      if (isSpecial) {
        // 检查保护罩
        if (gameStore.consumeProtection(target.name, ci)) {
          continue // 保护罩破裂，跳过该城市
        }

        const disguise = gameStore.disguisedCities &&
                        gameStore.disguisedCities[target.name] &&
                        gameStore.disguisedCities[target.name][ci]

        const currentHp = city.currentHp || city.hp
        if (disguise && disguise.roundsLeft > 0) {
          // 伪装城市：真实HP和伪装HP都减半
          const beforeReal = currentHp
          const beforeFox = disguise.disguiseAsHp || currentHp
          city.currentHp = Math.floor(currentHp / 2)
          if (disguise.disguiseAsHp !== undefined) {
            disguise.disguiseAsHp = Math.floor(disguise.disguiseAsHp / 2)
          }
          halvedCities.push({
            name: effectiveName,
            before: Math.floor(beforeFox),
            after: Math.floor(disguise.disguiseAsHp || city.currentHp)
          })
        } else {
          // 普通城市：只有真实HP
          const before = currentHp
          city.currentHp = Math.floor(currentHp / 2)
          halvedCities.push({
            name: effectiveName,
            before: Math.floor(before),
            after: Math.floor(city.currentHp)
          })
        }
      }
    }

    // 第二阶段：检查与己方同省的城市，非特殊城市归顺
    const citiesToRemove = []
    for (let ci = 0; ci < target.cities.length; ci++) {
      const city = target.cities[ci]
      if (!city || (city.currentHp || city.hp) <= 0) continue
      if (hasCenterCity && ci === oppCenterIndex) continue

      const effectiveName = getEffectiveName(target.name, ci)
      const isSpecial = isCapitalCity(effectiveName) ||
                       isPlanCity(effectiveName) ||
                       isMunicipality(effectiveName) ||
                       isSpecialAdministrativeRegion(effectiveName)

      // 特殊城市已经在第一阶段处理过了，跳过
      if (isSpecial) continue

      // 获取省份（考虑拔旗易帜）
      const prov = getCityProvince(target.name, ci, effectiveName)

      // 只有与己方同省的城市才归顺
      if (!prov || !myProvinces.has(prov)) continue

      // 检查是否有步步高升状态（免疫四面楚歌）
      if (gameStore.bbgs &&
          gameStore.bbgs[target.name] &&
          gameStore.bbgs[target.name][ci]) {
        gameStore.addLog(`${target.name}的${effectiveName}有步步高升状态，免疫四面楚歌`)
        continue
      }

      // 检查是否是伪装城市
      const disguise = gameStore.disguisedCities &&
                      gameStore.disguisedCities[target.name] &&
                      gameStore.disguisedCities[target.name][ci]

      if (disguise && disguise.roundsLeft > 0) {
        // 伪装城市：自毁并识破
        const currentHp = city.currentHp || city.hp
        city.currentHp = 0
        city.isAlive = false
        disguise.roundsLeft = 0
        exposedFoxCities.push({
          name: `${disguise.disguiseAsName}（实为${city.name}，狐假虎威被识破并自毁）`
        })
      } else {
        // 普通城市：正常归顺
        transferredCities.push({
          cityObj: JSON.parse(JSON.stringify(city)),
          originalIndex: ci
        })
        citiesToRemove.push(ci)
      }
    }

    // 保存被转移城市的initialCities数据（在删除之前）
    const transferredInitialCities = []
    for (const item of transferredCities) {
      let initialCity = null
      if (gameStore.initialCities && gameStore.initialCities[target.name]) {
        initialCity = gameStore.initialCities[target.name][item.originalIndex]
      }
      transferredInitialCities.push(initialCity || { name: item.cityObj.name, hp: item.cityObj.hp })
    }

    // 从对手那里移除归顺的城市（从后往前删除避免索引问题）
    let removedBeforeCenter = 0
    for (let i = citiesToRemove.length - 1; i >= 0; i--) {
      const ci = citiesToRemove[i]

      // 检查是否影响中心城市索引
      if (hasCenterCity && ci < oppCenterIndex) {
        removedBeforeCenter++
      }

      target.cities.splice(ci, 1)

      // 同步移除对手的initialCities数据
      if (gameStore.initialCities && gameStore.initialCities[target.name]) {
        gameStore.initialCities[target.name].splice(ci, 1)
      }

      // 移除相关状态
      if (gameStore.disguisedCities && gameStore.disguisedCities[target.name]) {
        delete gameStore.disguisedCities[target.name][ci]
      }
      if (gameStore.protectedCities && gameStore.protectedCities[target.name]) {
        delete gameStore.protectedCities[target.name][ci]
      }
      if (gameStore.ironCities && gameStore.ironCities[target.name]) {
        delete gameStore.ironCities[target.name][ci]
      }
    }

    // 调整中心城市索引
    if (hasCenterCity && removedBeforeCenter > 0) {
      target.centerIndex = Math.max(0, oppCenterIndex - removedBeforeCenter)
    }

    // 添加到己方
    for (let idx = 0; idx < transferredCities.length; idx++) {
      const item = transferredCities[idx]
      const city = item.cityObj
      const newIdx = caster.cities.length
      caster.cities.push(city)

      // 同步添加到己方的initialCities
      if (gameStore.initialCities) {
        if (!gameStore.initialCities[caster.name]) {
          gameStore.initialCities[caster.name] = []
        }
        gameStore.initialCities[caster.name].push(transferredInitialCities[idx])
      }

      // 标记归顺的城市为已知
      gameStore.setCityKnown(caster.name, newIdx, target.name)
    }

    // 构建日志消息
    let logMsg = `你对${target.name}使用了四面楚歌`
    if (transferredCities.length > 0) {
      const names = transferredCities.map(x => x.cityObj.name).join('、')
      logMsg += `，归顺城市：${names}`
    }

    if (halvedCities.length > 0) {
      const details = halvedCities.map(x => `${x.name}(${x.before}->${x.after})`).join('、')
      logMsg += `${transferredCities.length > 0 ? '；' : '，'}HP减半：${details}`
    }

    if (exposedFoxCities.length > 0) {
      const details = exposedFoxCities.map(x => x.name).join('、')
      logMsg += `${transferredCities.length > 0 || halvedCities.length > 0 ? '；' : '，'}${details}`
    }

    if (transferredCities.length === 0 && halvedCities.length === 0 && exposedFoxCities.length === 0) {
      logMsg += `，但没有符合条件的城市`
    }

    gameStore.addPrivateLog(caster.name, logMsg)
    gameStore.addLog(`${caster.name}对${target.name}使用了四面楚歌`)

    // 记录技能使用
    gameStore.lastSkillUsed = {
      userName: caster.name,
      skillName: '四面楚歌',
      cost: 23,
      roundNumber: gameStore.currentRound,
      timestamp: Date.now()
    }

    gameStore.recordSkillUsageTracking(caster.name, '四面楚歌')

    return {
      success: true,
      message: `四面楚歌！${transferredCities.length > 0 ? `归顺${transferredCities.length}座城市` : ''}${halvedCities.length > 0 ? ` 减半${halvedCities.length}座特殊城市` : ''}`,
      data: {
        transferredCities: transferredCities.map(x => x.cityObj.name),
        halvedCities: halvedCities,
        exposedFoxCities: exposedFoxCities
      }
    }
  }

  /**
   * 博学多才 - 答题增加HP
   * 选择己方1座原始HP≥25000的城市，回答3道该城市相关知识的单选题
   * 根据答对数量增加HP：0题x1, 1题x1.25, 2题x1.5, 3题x2
   *
   * @param {Object} caster - 施法者
   * @param {Number} cityIdx - 城市索引
   * @param {Number} correctCount - 答对题目数量 (0-3)
   * @returns {Object} { success, message, data }
   */
  function executeBoXueDuoCai(caster, cityIdx, correctCount = 0) {
    if (cityIdx === undefined) {
      return { success: false, message: '未选择城市' }
    }

    const selfCity = caster.cities[cityIdx]
    if (!selfCity) {
      return { success: false, message: '目标城市不存在' }
    }

    // 获取原始HP
    const initialCityData = gameStore.initialCities &&
                            gameStore.initialCities[caster.name] &&
                            gameStore.initialCities[caster.name][cityIdx]
    const originalHp = initialCityData ? initialCityData.hp : (selfCity.baseHp || selfCity.hp)

    // 检查原始HP是否≥25000
    if (originalHp < 25000) {
      return {
        success: false,
        message: `博学多才仅限原始HP≥25000的城市使用。${selfCity.name}原始HP为${Math.floor(originalHp)}`
      }
    }

    // 金币检查和扣除
    const goldCheck = checkAndDeductGold('博学多才', caster, gameStore)
    if (!goldCheck.success) {
      return goldCheck
    }

    // 创建快照
    gameStore.createGameStateSnapshot()

    // 验证答对数量
    if (typeof correctCount !== 'number' || correctCount < 0 || correctCount > 3) {
      correctCount = 0
    }

    // 计算HP倍数：0题x1, 1题x1.25, 2题x1.5, 3题x2
    const hpMultipliers = [1, 1.25, 1.5, 2]
    const multiplier = hpMultipliers[correctCount]

    // 应用HP倍数
    const currentHp = selfCity.currentHp || selfCity.hp
    const oldHp = currentHp
    selfCity.currentHp = Math.floor(currentHp * multiplier)

    // 应用HP上限（如果gameStore有上限功能）
    if (gameStore.applyPlayerHpCap) {
      gameStore.applyPlayerHpCap(caster.name, cityIdx, selfCity)
    }

    const hpGain = selfCity.currentHp - oldHp

    // 获取显示名称（处理狐假虎威伪装）
    let displayCityName = selfCity.name
    if (gameStore.disguisedCities &&
        gameStore.disguisedCities[caster.name] &&
        gameStore.disguisedCities[caster.name][cityIdx]) {
      const disguise = gameStore.disguisedCities[caster.name][cityIdx]
      if (disguise.roundsLeft > 0) {
        displayCityName = disguise.disguiseAsName || selfCity.name
      }
    }

    // 添加日志
    const resultSummary = `答对${correctCount}题，HP×${multiplier}（${Math.floor(oldHp)} → ${selfCity.currentHp}，+${hpGain}）`

    if (gameStore.addPrivateLog) {
      gameStore.addPrivateLog(caster.name, `你对${displayCityName}使用了博学多才：${resultSummary}`)
    }

    gameStore.addLog(`${caster.name}使用了博学多才`)

    // 记录技能使用
    gameStore.lastSkillUsed = {
      userName: caster.name,
      skillName: '博学多才',
      cost: 6,
      roundNumber: gameStore.currentRound,
      timestamp: Date.now()
    }

    gameStore.recordSkillUsageTracking(caster.name, '博学多才')

    return {
      success: true,
      message: `博学多才：${resultSummary}`,
      data: {
        cityName: displayCityName,
        correctCount: correctCount,
        multiplier: multiplier,
        oldHp: oldHp,
        newHp: selfCity.currentHp,
        hpGain: hpGain
      }
    }
  }

  // 导出所有非战斗技能（完整版）
  return {
    executeTransferGold,
    executeWuZhiWuWei,
    executeKuaiSuZhiLiao,
    executeCityProtection,
    executeGangTieChengShi,
    executeShiLiZengQiang,
    executeJieShiHuanHun,
    executeShiQiDaZhen,
    executeQingChuJiaCheng,
    executeShiLaiYunZhuan,
    executeXianShengDuoRen,
    executeJinBiDaiKuan,
    executeDingHaiShenZhen,
    executeHuanRanYiXin,
    executeGouYanCanChuan,
    executeGaoJiZhiLiao,
    executeZhongZhiChengCheng,
    executeWuZhongShengYou,
    executeHaoGaoWuYuan,
    executeHuJiaHuWei,
    executePaoZhuanYinYu,
    executeJinZhiNiuQu,
    executeTiDengDingSun,
    executeLianXuDaJi,
    executeBoTaoXiongYong,
    executeKuangHongLanZha,
    executeHengSaoYiKong,
    executeWanJianQiFa,
    executeJiangWeiDaJi,
    executeShenCangBuLu,
    executeDingShiBaoPo,
    executeYongJiuCuiHui,
    executeZhanLueZhuanYi,
    executeLianSuoFanYing,
    executeZhaoXianNaShi,
    executeWuXieKeJi,
    executeJianBuKeCui,
    executeYiHuaJieMu,
    executeBuLuZongJi,
    executeZhengQiHuaYi,
    executeRenZhiJiaoHuan,
    executeFuDiChouXin,
    // 新增技能 (2024-12-28)
    executeJinRongWeiJi,
    executeJieFuJiPin,
    executeGaiXianGengZhang,
    executeChengShiShiLian,      // 城市试炼 (4金币)
    executeTianZaiRenHuo,
    executeLiDaiTaoJiang,
    executeBiErBuJian,
    executeYiChuJiFa,
    executeJiNengBaoHu,
    executeTuPoPingJing,
    // 第三批新增 (2024-12-28)
    executeXueLiangCunChu,
    executeHaiShiShenLou,
    executeJieChuFengSuo,
    executeShuWeiFanZhuan,
    executeMuBuZhuanJing,
    executeGuoHeChaiQiao,
    executeDianCiGanYing,
    // 第四批新增 - 状态控制类 (2024-12-28)
    executeHouJiBaoFa,
    executeZhongYongZhiDao,
    executeDangJiLiDuan,
    executeZiXiangCanSha,
    executeYanTingJiCong,
    executeShiBanGongBei,
    executeDaoFanTianGang,
    // 第五批新增 - 城市操作类 (2024-12-28)
    executeBanyunJiubingPutong,
    executeBanyunJiubingGaoji,
    executeChenqibubeiSuiji,
    executeChenqibubeiZhiding,
    // 第六批新增 - 城市操作类（续） (2024-12-28)
    executeBaQiYiZhi,
    executeShouWangXiangZhu,
    executeYiLiLaiJiang,
    executeDaYiMieQin,
    executeQiangZhiQianDuPutong,
    executeQiangZhiQianDuGaoji,
    executeYiWeiPingDi,
    executeQiangZhiBanYun,
    // 第七批新增 - 省会相关技能 (2024-12-28)
    executeXingZhengZhongXin,
    executeDaiXingShengQuan,
    executeFuZhongXinZhi,
    executeJiHuaDanLie,
    executeBuBuGaoSheng,
    executeShengYuZiShi,
    // 第八批新增 - 侦查类技能 (2024-12-28)
    executeCityDetective,
    executeChengShiYuYan,
    executeYiJuLiangDe,
    executeMingChaQiuHao,
    // 第九批新增 - 最高级技能 (2024-12-28)
    executeSiMianChuGe,
    executeBoXueDuoCai
  }
}

